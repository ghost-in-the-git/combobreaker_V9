<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C O M B O B R E A K E R</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0f;
            color: #00ff88;
            min-height: 100vh;
            display: flex;
        }

        /* Stats Panel */
        .stats-panel {
            width: 450px;
            background: #12121a;
            border-right: 2px solid #00ff88;
            padding: 20px;
            display: flex;
            flex-direction: column;
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            overflow-y: auto;
        }

        /* Offset chat panel for fixed stats */
        .chat-panel {
            margin-left: 450px;
        }

        .stats-panel h2 {
            text-align: center;
            margin-bottom: 20px;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff8855;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0 12px;
            margin-top: 0;
        }

        .stat-grid-top {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 0 12px;
            margin-top: 20px;
        }

        .stat-divider {
            border: none;
            border-top: 1px solid #00ff8844;
            margin: 6px 0;
        }

        .mech-idle {
            width: 100%;
            aspect-ratio: 1 / 1;
            object-fit: cover;
            image-rendering: pixelated;
            display: block;
            margin-top: 10px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid #00ff8833;
        }

        .stat-label {
            color: #00ff88;
        }

        .stat-right {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .stat-value {
            color: #00ff88;
            font-weight: bold;
        }

        .stat-upgrade {
            background: #1a2e1a;
            border: 1px solid #00ff88;
            color: #00ff88;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            font-weight: bold;
            width: 20px;
            height: 20px;
            line-height: 18px;
            text-align: center;
            padding: 0;
            border-radius: 3px;
            cursor: pointer;
        }

        .stat-upgrade:hover {
            background: #00ff88;
            color: #0a0a0f;
        }

        .stat-upgrade:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .hp-bar-container {
            margin-top: 20px;
            background: #1a1a2e;
            border: 1px solid #00ff88;
            border-radius: 4px;
            overflow: hidden;
        }

        .hp-bar {
            height: 8px;
            background: linear-gradient(90deg, #00ff88, #00cc66);
            transition: width 0.3s ease;
        }

        .hp-label {
            text-align: center;
            font-size: 11px;
            color: #00ff88;
            margin-top: 4px;
        }

        .xp-bar-container {
            margin-top: 10px;
            background: #1a1a2e;
            border: 1px solid #00bbff;
            border-radius: 4px;
            overflow: hidden;
        }

        .xp-bar {
            height: 8px;
            background: linear-gradient(90deg, #00bbff, #0088cc);
            transition: width 0.3s ease;
        }

        .xp-label {
            text-align: center;
            font-size: 11px;
            color: #00bbff;
            margin-top: 4px;
        }

        .fuel-bar-container {
            margin-top: 10px;
            background: #1a1a2e;
            border: 1px solid #ff8800;
            border-radius: 4px;
            overflow: hidden;
        }

        .fuel-bar {
            height: 8px;
            background: linear-gradient(90deg, #ff8800, #cc6600);
            transition: width 0.3s ease;
        }

        .fuel-label {
            text-align: center;
            font-size: 11px;
            color: #ff8800;
            margin-top: 4px;
        }

        /* Storage Panel */
        .storage-panel {
            padding: 10px 0;
        }

        .storage-label {
            color: #00ff88;
            font-size: 12px;
        }

        .storage-desc-content {
            display: flex;
            gap: 8px;
            align-items: flex-start;
            padding: 6px 8px;
            background: #1a1a2e;
            border: 1px solid #00ff8833;
            border-radius: 4px;
            margin-top: 4px;
        }

        .storage-desc-content img {
            width: 48px;
            height: 48px;
            image-rendering: pixelated;
            flex-shrink: 0;
            border: 1px solid #00ff8833;
            border-radius: 4px;
        }

        .storage-desc-content span {
            color: #ddd;
            font-size: 12px;
            line-height: 1.2;
        }

        /* Chat Panel */
        .chat-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #0d0d14;
        }

        .chat-messages {
            flex: 1;
            padding: 20px;
            padding-bottom: 100px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .message {
            display: flex;
            align-items: flex-start;
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid transparent;
            animation: fadeIn 0.3s ease;
            gap: 12px;
            box-sizing: border-box;
        }

        .message-avatar {
            width: 64px;
            height: 64px;
            min-width: 64px;
            border-radius: 4px;
            overflow: hidden;
            border: none;
        }

        .message-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .message-avatar.character-avatar {
            width: 256px;
            height: 256px;
            min-width: 256px;
            image-rendering: pixelated;
        }

        .message-content {
            flex: 1;
            min-width: 0;
        }

        .message-label {
            font-size: 10px;
            font-weight: bold;
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .message-text {
            line-height: 1.4;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.system {
            background: #0a0a12;
            border-color: #00ff88;
            color: #00ff88;
        }
        .message.system .message-label { color: #00ff88; }

        .message.systemblue {
            background: #0a0a12;
            border-color: #4488ff;
            color: #0000ff;
        }
        .message.systemblue .message-label { color: #4488ff; }

        .message.enemy {
            background: #2a1a1a;
            border-color: #ff4444;
            color: #ff6666;
        }
        .message.enemy .message-label { color: #ff4444; }

        .message.player {
            background: #1a1a2e;
            border-color: #4488ff;
            color: #88aaff;
        }
        .message.player .message-label { color: #4488ff; }

        .message.battle {
            background: #1a1a2e;
            border-color: #4488ff;
            color: #88aaff;
            font-style: italic;
        }
        .message.battle .message-label { color: #4488ff; }

        .message.damage {
            background: #2a1a2a;
            border-color: #ff44aa;
            color: #ff88cc;
        }
        .message.damage .message-label { color: #ff44aa; }

        .message.victory {
            background: #1a2a2a;
            border-color: #00ffcc;
            color: #00ffcc;
        }
        .message.victory .message-label { color: #00ffcc; }

        .message.defeat {
            background: #2a1a1a;
            border-color: #ff0000;
            color: #ff4444;
            font-weight: bold;
        }
        .message.defeat .message-label { color: #ff0000; }

        .message.levelup {
            background: #2a2a1a;
            border-color: #ffdd00;
            color: #ffdd00;
            font-weight: bold;
        }
        .message.levelup .message-label { color: #ffdd00; }

        .message.turncounter {
            background: #1a1a1a;
            border-color: #666;
            color: #999;
            text-align: center;
        }
        .message.turncounter .message-label { color: #888; }
        .message.turncounter .message-avatar { display: none; }

        /* Equipment Panel */
        .equipment-panel {
            margin-top: 10px;
        }

        .equipment-panel h4 {
            color: #00ff88;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .equip-slot {
            margin-bottom: 8px;
        }

        .equip-slot label {
            display: block;
            font-size: 10px;
            color: #888;
            margin-bottom: 2px;
        }

        .equip-slot select {
            width: 100%;
            padding: 8px 24px 8px 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: #1a1a2e;
            color: #00ff88;
            border: 1px solid #00ff8855;
            border-radius: 4px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%2300ff88'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
        }

        .equip-slot select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .equip-slot select:focus {
            outline: none;
            border-color: #00ff88;
        }

        .beacon-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .beacon-row select {
            flex: 1;
        }

        .toggle-switch {
            position: relative;
            width: 36px;
            min-width: 36px;
            height: 18px;
            background: #1a1a2e;
            border: 1px solid #00ff8855;
            border-radius: 9px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .toggle-switch.on {
            background: #00ff8833;
            border-color: #00ff88;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 12px;
            height: 12px;
            background: #555;
            border-radius: 50%;
            transition: transform 0.2s, background 0.2s;
        }

        .toggle-switch.on::after {
            transform: translateX(18px);
            background: #00ff88;
        }

        /* Action Buttons (inline in chat) */
        .action-btn-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 10px 0;
        }

        .action-btn {
            padding: 10px 30px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            border: 2px solid;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
        }

        .action-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .action-btn.engage {
            background: #1a2a1a;
            border-color: #00ff88;
            color: #00ff88;
        }

        .action-btn.engage:hover:not(:disabled) {
            background: #00ff88;
            color: #0a0a0f;
            box-shadow: 0 0 20px #00ff8855;
        }

        .action-btn.retreat {
            background: #2a1a1a;
            border-color: #ff4444;
            color: #ff4444;
        }

        .action-btn.retreat:hover:not(:disabled) {
            background: #ff4444;
            color: #0a0a0f;
            box-shadow: 0 0 20px #ff444455;
        }

        /* Dialogue Buttons */
        .dialogue-btn-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            padding: 10px 0;
        }

        .dialogue-btn {
            padding: 6px 14px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 12px;
            font-weight: bold;
            border: 1px solid #ccaa44;
            border-radius: 4px;
            cursor: pointer;
            background: #1a1a10;
            color: #ccaa44;
            transition: all 0.2s ease;
        }

        .dialogue-btn:hover {
            background: #ccaa44;
            color: #0a0a0f;
            box-shadow: 0 0 15px #ccaa4455;
        }

        /* Shop Panel */
        .shop-panel {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }

        .shop-item-wrapper {
            display: none;
        }

        .shop-item-wrapper.visible {
            display: block;
        }

        .shop-name {
            padding: 8px 10px;
            background: #1a1a2e;
            border: 1px solid #00ff88;
            border-radius: 4px 4px 0 0;
            color: #00ff88;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            font-weight: bold;
        }

        .shop-name.cant-afford {
            border-color: #ff4444;
            color: #ff4444;
        }

        .shop-desc {
            padding: 0;
            background: #1a1a2e;
            border: 1px solid #00ff8833;
            border-top: none;
        }

        .shop-name.cant-afford + .shop-desc {
            border-color: #ff444433;
        }

        .shop-buy-btn {
            padding: 8px 12px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            font-weight: bold;
            border: 1px solid #00ff88;
            border-top: none;
            border-radius: 0 0 4px 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #1a1a2e;
            color: #00ff88;
            text-align: center;
            width: 100%;
        }

        .shop-buy-btn:hover:not(:disabled) {
            background: #00ff88;
            color: #0a0a0f;
            box-shadow: 0 0 15px #00ff8855;
        }

        .shop-buy-btn:disabled {
            cursor: not-allowed;
            border-color: #666;
            color: #ff4444;
            opacity: 0.7;
        }

        /* Forge Mineral Selector */
        .forge-selector {
            margin-bottom: 8px;
        }

        .forge-selector select {
            width: 100%;
            padding: 8px 24px 8px 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: #1a1a2e;
            color: #ff8800;
            border: 1px solid #ff880055;
            border-radius: 4px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%23ff8800'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
        }

        .forge-selector select:focus {
            outline: none;
            border-color: #ff8800;
        }

        /* Salvage Yard Selector */
        .salvage-selector {
            margin-bottom: 8px;
        }

        .salvage-selector select {
            width: 100%;
            padding: 8px 24px 8px 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: #1a1a2e;
            color: #ffcc00;
            border: 1px solid #ffcc0055;
            border-radius: 4px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%23ffcc00'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
        }

        .salvage-selector select:focus {
            outline: none;
            border-color: #ffcc00;
        }

        /* Decrypter Selector */
        .decrypter-selector {
            margin-bottom: 8px;
        }

        .decrypter-selector select {
            width: 100%;
            padding: 8px 24px 8px 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: #1a1a2e;
            color: #00ccff;
            border: 1px solid #00ccff55;
            border-radius: 4px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%2300ccff'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
        }

        .decrypter-selector select:focus {
            outline: none;
            border-color: #00ccff;
        }

        .salvage-preview {
            padding: 8px 10px;
            background: #1a1a2e;
            border: 1px solid #ffcc0033;
            border-radius: 4px;
            margin-top: 8px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #ccc;
            display: none;
        }

        .salvage-preview.visible {
            display: block;
        }

        .salvage-preview .salvage-item-name {
            color: #ffcc00;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .salvage-preview .salvage-item-stats {
            color: #888;
            font-size: 10px;
        }

        .salvage-sell-btn {
            padding: 8px 12px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            font-weight: bold;
            border: 1px solid #ffcc00;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #1a1a2e;
            color: #ffcc00;
            text-align: center;
            width: 100%;
            margin-top: 8px;
        }

        .salvage-sell-btn:hover:not(:disabled) {
            background: #ffcc00;
            color: #0a0a0f;
            box-shadow: 0 0 15px #ffcc0055;
        }

        .salvage-sell-btn:disabled {
            cursor: not-allowed;
            border-color: #666;
            color: #888;
            opacity: 0.7;
        }

        .salvage-sell-all-btn {
            border-color: #ff6644;
            color: #ff6644;
            margin-top: 6px;
        }

        .salvage-sell-all-btn:hover:not(:disabled) {
            background: #ff6644;
            color: #0a0a0f;
            box-shadow: 0 0 15px #ff664455;
        }

        .shop-btn {
            padding: 10px 12px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            border: 1px solid #4488ff;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #1a1a2e;
            color: #4488ff;
            text-align: left;
            width: 100%;
        }





        .timer-display {
            text-align: center;
            padding: 10px;
            color: #666;
            font-size: 12px;
        }

        .save-indicator {
            text-align: center;
            font-size: 10px;
            color: #00ff88;
            opacity: 0;
            transition: opacity 0.3s ease;
            margin-top: 5px;
        }

        .save-indicator.visible {
            opacity: 1;
        }

        /* Options Button */
        .options-btn {
            background: #1a1a2e;
            border: 1px solid #00ff8855;
            color: #00ff88;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .options-btn:hover {
            background: #00ff88;
            color: #0a0a0f;
        }

        /* Save Slot Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal {
            background: #12121a;
            border: 2px solid #00ff88;
            border-radius: 8px;
            padding: 20px;
            width: 420px;
            max-width: 90vw;
        }

        .modal h3 {
            color: #00ff88;
            text-align: center;
            margin-bottom: 15px;
        }

        .save-slot {
            background: #1a1a2e;
            border: 1px solid #00ff8833;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .save-slot.active {
            border-color: #00ff88;
            box-shadow: 0 0 8px #00ff8833;
        }

        .save-slot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .save-slot-title {
            color: #00ff88;
            font-weight: bold;
            font-size: 13px;
        }

        .save-slot-info {
            color: #888;
            font-size: 11px;
            line-height: 1.6;
        }

        .save-slot-info span {
            color: #00ff88;
        }

        .save-slot-empty {
            color: #555;
            font-size: 11px;
            font-style: italic;
        }

        .save-slot-actions {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }

        .slot-btn {
            font-family: 'Courier New', monospace;
            font-size: 10px;
            padding: 4px 10px;
            border-radius: 3px;
            border: 1px solid;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .slot-btn.load {
            background: #1a1a2e;
            border-color: #4488ff;
            color: #4488ff;
        }

        .slot-btn.load:hover {
            background: #4488ff;
            color: #0a0a0f;
        }

        .slot-btn.new-game {
            background: #1a2e1a;
            border-color: #00ff88;
            color: #00ff88;
        }

        .slot-btn.new-game:hover {
            background: #00ff88;
            color: #0a0a0f;
        }

        .slot-btn.delete {
            background: #2a1a1a;
            border-color: #ff4444;
            color: #ff4444;
        }

        .slot-btn.delete:hover {
            background: #ff4444;
            color: #0a0a0f;
        }

        .slot-btn.boost-xp {
            background: #1a1a2e;
            border-color: #ffaa00;
            color: #ffaa00;
        }

        .slot-btn.boost-xp:hover {
            background: #ffaa00;
            color: #0a0a0f;
        }

        .slot-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .modal-close {
            display: block;
            width: 100%;
            margin-top: 10px;
            padding: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: #1a1a2e;
            border: 1px solid #888;
            color: #888;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: #888;
            color: #0a0a0f;
        }

        .confirm-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1100;
            justify-content: center;
            align-items: center;
        }

        .confirm-overlay.visible {
            display: flex;
        }

        .confirm-box {
            background: #12121a;
            border: 2px solid #ff4444;
            border-radius: 8px;
            padding: 20px;
            width: 320px;
            max-width: 90vw;
            text-align: center;
        }

        .confirm-box p {
            color: #ccc;
            margin-bottom: 16px;
            font-size: 13px;
        }

        .confirm-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .confirm-btn {
            padding: 8px 24px;
            border: 1px solid;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
        }

        .confirm-btn.yes {
            background: #ff4444;
            border-color: #ff4444;
            color: #fff;
        }

        .confirm-btn.yes:hover {
            background: #ff6666;
        }

        .confirm-btn.no {
            background: transparent;
            border-color: #00ff88;
            color: #00ff88;
        }

        .confirm-btn.no:hover {
            background: #00ff88;
            color: #0a0a0f;
        }

        /* Location Panel */
        .location-panel {
            margin-top: 10px;
        }

        .location-panel h4 {
            color: #00ff88;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .location-image-container {
            width: 100%;
            aspect-ratio: 1 / 1;
            overflow: hidden;
            border-radius: 4px;
            border: 1px solid #00ff8855;
            margin-bottom: 8px;
        }

        .location-image-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            image-rendering: pixelated;
        }

        .location-desc {
            margin-top: 4px;
        }

        /* Mining Panel */
        .mining-panel {
            margin-top: 10px;
        }

        .mining-panel h4 {
            color: #00ff88;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .mining-category {
            margin-bottom: 6px;
        }

        .mining-cat-label {
            display: block;
            font-size: 10px;
            font-weight: bold;
            margin-bottom: 3px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .mining-cat-label.common { color: #aaaaaa; }
        .mining-cat-label.uncommon { color: #44cc44; }
        .mining-cat-label.scarce { color: #4488ff; }
        .mining-cat-label.valuable { color: #aa44ff; }
        .mining-cat-label.precious { color: #ffaa00; }
        .mining-cat-label.exotic { color: #ff4488; }
        .mining-cat-label.ultrarare { color: #ff44ff; }

        .mining-category select {
            width: 100%;
            background: #1a1a2e;
            color: #00ff88;
            border: 1px solid #00ff8855;
            border-radius: 4px;
            padding: 8px 24px 8px 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%2300ff88'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
        }

        .equip-desc {
            margin-top: 4px;
            display: none;
        }

        .equip-desc.visible {
            display: block;
        }

        /* Panel Pages */
        .panel-page {
            display: none;
            flex-direction: column;
            flex: 1;
        }

        .panel-page.active {
            display: flex;
        }

        .panel-nav {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 4px;
            padding: 8px 0;
            margin-top: auto;
            border-top: 1px solid #00ff8844;
        }

        .nav-icon {
            width: 50px;
            height: 50px;
            background: #1a1a2e;
            border: 1px solid #00ff8833;
            border-radius: 4px;
            cursor: pointer;
            padding: 4px;
            transition: all 0.2s ease;
            opacity: 0.4;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .nav-icon img {
            width: 38px;
            height: 38px;
            image-rendering: pixelated;
        }

        .nav-icon:hover {
            opacity: 0.8;
            border-color: #00ff8888;
            box-shadow: 0 0 8px #00ff8844;
        }

        .nav-icon.active {
            opacity: 1;
            border-color: #00ff88;
            box-shadow: 0 0 12px #00ff8866;
        }

        .nav-icon.hidden {
            display: none;
        }

        /* Scrollbar */
        .chat-messages::-webkit-scrollbar {
            width: 8px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: #12121a;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: #00ff8855;
            border-radius: 4px;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: #00ff88;
        }
    </style>
</head>
<body>
    <div class="stats-panel">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <h3>COMBOBREAKER</h3>
            <button class="options-btn" id="btn-options">LOAD</button>
        </div>
        <h4>/// v1.7.0</h4>

        <div class="hp-bar-container">
            <div class="hp-bar" id="hp-bar" style="width: 100%"></div>
        </div>
        <div class="hp-label" id="hp-label">HP: 100 / 100</div>

        <div class="xp-bar-container">
            <div class="xp-bar" id="xp-bar" style="width: 0%"></div>
        </div>
        <div class="xp-label" id="xp-label">SILICON: 0 / 10</div>

        <div class="fuel-bar-container">
            <div class="fuel-bar" id="fuel-bar" style="width: 100%"></div>
        </div>
        <div class="fuel-label" id="fuel-label">FUEL: 100 / 100</div>

        <div class="panel-page active" id="page-stats">
            <div class="stat-grid-top">
                <div class="stat-row">
                    <span class="stat-label">Level</span>
                    <span class="stat-value" id="stat-level">1</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Silicon</span>
                    <span class="stat-value" id="stat-xp">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ReqSi</span>
                    <span class="stat-value" id="stat-reqxp">10</span>
                </div>
            </div>
            <hr class="stat-divider">
            <div class="stat-grid">
                <div class="stat-row">
                    <span class="stat-label">Attack</span>
                    <span class="stat-right"><span class="stat-value" id="stat-attack">0</span><button class="stat-upgrade" onclick="upgradeStat('attack')">+</button></span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Breaker</span>
                    <span class="stat-right"><span class="stat-value" id="stat-breaker">0%</span><button class="stat-upgrade" onclick="upgradeStat('breaker')">+</button></span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Defence</span>
                    <span class="stat-right"><span class="stat-value" id="stat-defence">0</span><button class="stat-upgrade" onclick="upgradeStat('defence')">+</button></span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Regen</span>
                    <span class="stat-right"><span class="stat-value" id="stat-regen">0</span><button class="stat-upgrade" onclick="upgradeStat('regen')">+</button></span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Speed</span>
                    <span class="stat-right"><span class="stat-value" id="stat-speed">0</span><button class="stat-upgrade" onclick="upgradeStat('speed')">+</button></span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Mining</span>
                    <span class="stat-right"><span class="stat-value" id="stat-mining">0</span><button class="stat-upgrade" onclick="upgradeStat('mining')">+</button></span>
                </div>
            </div>

            <img src="images/COMBOBREAKER_IDLE.gif" alt="COMBOBREAKER" class="mech-idle">

            <div class="timer-display" id="timer-display">
                Next  in: --:--
            </div>
            <div class="save-indicator" id="save-indicator">
                [SAVED]
            </div>

        </div>

        <div class="panel-page" id="page-installations">
            <div class="equipment-panel">
                <div class="equip-slot">
                    <select id="equip-body"><option value="">-- None --</option></select>
                    <div class="equip-desc" id="equip-desc-body"></div>
                </div>
                <div class="equip-slot">
                    <select id="equip-legs"><option value="">-- None --</option></select>
                    <div class="equip-desc" id="equip-desc-legs"></div>
                </div>
                <div class="equip-slot">
                    <select id="equip-arms"><option value="">-- None --</option></select>
                    <div class="equip-desc" id="equip-desc-arms"></div>
                </div>
                <div class="equip-slot">
                    <select id="equip-weapon"><option value="">-- None --</option></select>
                    <div class="equip-desc" id="equip-desc-weapon"></div>
                </div>
                <div class="equip-slot">
                    <select id="equip-chip"><option value="">-- None --</option></select>
                    <div class="equip-desc" id="equip-desc-chip"></div>
                </div>
                <div class="equip-slot">
                    <select id="equip-processor"><option value="">-- None --</option></select>
                    <div class="equip-desc" id="equip-desc-processor"></div>
                </div>
            </div>
        </div>

        <div class="panel-page" id="page-pilot">
            <div class="equipment-panel">
                <div class="equip-slot">
                    <select id="equip-pilot"><option value="">-- None --</option></select>
                    <div class="equip-desc" id="equip-desc-pilot"></div>
                </div>
                <div class="equip-slot">
                    <select id="equip-implant"><option value="">-- None --</option></select>
                    <div class="equip-desc" id="equip-desc-implant"></div>
                </div>
                <div class="equip-slot">
                    <select id="equip-mindsync"><option value="">-- None --</option></select>
                    <div class="equip-desc" id="equip-desc-mindsync"></div>
                </div>
            </div>
        </div>

        <div class="panel-page" id="page-location">
            <div class="location-panel">
                <div class="equip-slot">
                    <select id="location-select">
                    </select>
                </div>
                <div class="location-image-container">
                    <img id="location-image" src="images/LOCATION.gif" alt="Location">
                </div>
                <div class="equip-slot">
                    <select id="destination-select">
                    </select>
                </div>
                <div class="location-desc" id="location-desc">
                    <div class="storage-desc-content"><img src="images/IMAGE.gif" alt="Location"><span>Piles of rusted mechs and salvageable parts. Low-threat scavenger bots roam the wreckage.</span></div>
                </div>
                <hr>
                <div class="equip-slot">
                    <div class="beacon-row">
                        <select id="storage-beacon"><option value="">[BEACONS] -- Empty --</option></select>
                        <div id="boss-toggle" class="toggle-switch on" title="Boss encounters ON"></div>
                    </div>
                    <div class="storage-desc" id="storage-desc-beacon"></div>
                </div>
            </div>
        </div>

        <div class="panel-page" id="page-mining">
            <div class="mining-panel">
                <div class="equip-slot">
                    <select id="equip-drill"><option value="">-- None --</option></select>
                    <div class="equip-desc" id="equip-desc-drill"></div>
                </div>
                <div class="mining-category">
                    <select id="mining-tier1" disabled>
                        <option value="">[TIER 1] -- Empty --</option>
                        <option value="aetherite">[TIER 1] Aetherite</option>
                        <option value="bronzewisp">[TIER 1] Bronzewisp</option>
                        <option value="cindergem">[TIER 1] Cindergem</option>
                    </select>
                </div>
                <div class="mining-category">
                    <select id="mining-tier2" disabled>
                        <option value="">[TIER 2] -- Empty --</option>
                        <option value="duskquartz">[TIER 2] Duskquartz</option>
                        <option value="emberlith">[TIER 2] Emberlith</option>
                        <option value="frostveil">[TIER 2] Frostveil</option>
                    </select>
                </div>
                <div class="mining-category">
                    <select id="mining-tier3" disabled>
                        <option value="">[TIER 3] -- Empty --</option>
                        <option value="gloomstone">[TIER 3] Gloomstone</option>
                        <option value="hexsilica">[TIER 3] Hexsilica</option>
                        <option value="iridionite">[TIER 3] Iridionite</option>
                    </select>
                </div>
                <div class="mining-category">
                    <select id="mining-tier4" disabled>
                        <option value="">[TIER 4] -- Empty --</option>
                        <option value="jetspinel">[TIER 4] Jetspinel</option>
                        <option value="kryptoglass">[TIER 4] Kryptoglass</option>
                        <option value="lumenore">[TIER 4] Lumenore</option>
                    </select>
                </div>
                <div class="mining-category">
                    <select id="mining-tier5" disabled>
                        <option value="">[TIER 5] -- Empty --</option>
                        <option value="moonshardite">[TIER 5] Moonshardite</option>
                        <option value="nightpyre">[TIER 5] Nightpyre</option>
                        <option value="obsidryl">[TIER 5] Obsidryl</option>
                    </select>
                </div>
                <div class="mining-category">
                    <select id="mining-tier6" disabled>
                        <option value="">[TIER 6] -- Empty --</option>
                        <option value="prismalune">[TIER 6] Prismalune</option>
                        <option value="quellium">[TIER 6] Quellium</option>
                        <option value="riftmarble">[TIER 6] Riftmarble</option>
                    </select>
                </div>
                <div class="mining-category">
                    <select id="mining-tier7" disabled>
                        <option value="">[TIER 7] -- Empty --</option>
                        <option value="starvitrine">[TIER 7] Starvitrine</option>
                        <option value="thorncrystal">[TIER 7] Thorncrystal</option>
                        <option value="umbracite">[TIER 7] Umbracite</option>
                    </select>
                </div>
                <div class="mining-category">
                    <select id="mining-tier8" disabled>
                        <option value="">[TIER 8] -- Empty --</option>
                        <option value="vortexium">[TIER 8] Vortexium</option>
                        <option value="wyrmstone">[TIER 8] Wyrmstone</option>
                        <option value="xanthryx">[TIER 8] Xanthryx</option>
                    </select>
                </div>
                <div class="mining-category">
                    <select id="mining-tier9" disabled>
                        <option value="">[TIER 9] -- Empty --</option>
                        <option value="yonderite">[TIER 9] Yonderite</option>
                        <option value="zephyrsalt">[TIER 9] Zephyrsalt</option>
                        <option value="isotope lace">[TIER 9] Isotope Lace</option>
                    </select>
                </div>
                <div class="mining-category">
                    <select id="mining-tier10" disabled>
                        <option value="">[TIER 10] -- Empty --</option>
                        <option value="archive shard">[TIER 10] Archive Shard</option>
                        <option value="strata-null">[TIER 10] Strata-Null</option>
                        <option value="compound 33">[TIER 10] Compound 33</option>
                    </select>
                </div>
                <div class="mining-category">
                    <select id="mining-refined" disabled>
                        <option value="">[REFINED] -- Empty --</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="panel-page" id="page-storage">
            <div class="storage-panel">
                <div class="equip-slot">
                    <select id="storage-log"><option value="">[LOGS] -- Empty --</option></select>
                    <div class="storage-desc" id="storage-desc-log"></div>
                </div>
                <div class="equip-slot">
                    <select id="storage-key"><option value="">[KEYS] -- Empty --</option></select>
                    <div class="storage-desc" id="storage-desc-key"></div>
                </div>
                <div class="equip-slot">
                    <select id="storage-dna"><option value="">[DNA] -- Empty --</option></select>
                    <div class="storage-desc" id="storage-desc-dna"></div>
                </div>
                <div class="equip-slot">
                    <select id="storage-debris"><option value="">[DEBRIS] -- Empty --</option></select>
                    <div class="storage-desc" id="storage-desc-debris"></div>
                </div>
                <div class="equip-slot">
                    <select id="storage-scrap"><option value="">[SCRAP] -- Empty --</option></select>
                    <div class="storage-desc" id="storage-desc-scrap"></div>
                </div>
                <div class="equip-slot">
                    <select id="storage-map"><option value="">[MAPS] -- Empty --</option></select>
                    <div class="storage-desc" id="storage-desc-map"></div>
                </div>
                <div class="equip-slot">
                    <select id="storage-locationmap"><option value="">[LOCATIONS] -- Empty --</option></select>
                    <div class="storage-desc" id="storage-desc-locationmap"></div>
                </div>
            </div>
        </div>

        <div class="panel-page" id="page-store">
            <div class="shop-panel" id="shop-panel">
                <div class="forge-selector" id="forge-selector" style="display: none;">
                    <select id="forge-mineral-select">
                        <option value="">[SELECT MINERAL]</option>
                    </select>
                </div>
                <div class="decrypter-selector" id="decrypter-selector" style="display: none;">
                    <select id="decrypter-key-select">
                        <option value="">[SELECT KEY TO DECRYPT]</option>
                    </select>
                </div>
                <div class="salvage-selector" id="salvage-selector" style="display: none;">
                    <select id="salvage-item-select">
                        <option value="">[SELECT INSTALLATION TO SELL]</option>
                    </select>
                    <div class="salvage-preview" id="salvage-preview"></div>
                    <button class="salvage-sell-btn" id="salvage-sell-btn" disabled>--</button>
                    <button class="salvage-sell-btn salvage-sell-all-btn" id="salvage-sell-all-btn" style="display: none;">--</button>
                </div>
                <div class="shop-item-wrapper" id="shop-wrapper-1">
                    <div class="shop-name" id="shop-name-1"></div>
                    <div class="shop-desc" id="shop-desc-1"></div>
                    <button class="shop-buy-btn" id="shop-buy-1" disabled>--</button>
                </div>
                <div class="shop-item-wrapper" id="shop-wrapper-2">
                    <div class="shop-name" id="shop-name-2"></div>
                    <div class="shop-desc" id="shop-desc-2"></div>
                    <button class="shop-buy-btn" id="shop-buy-2" disabled>--</button>
                </div>
                <div class="shop-item-wrapper" id="shop-wrapper-3">
                    <div class="shop-name" id="shop-name-3"></div>
                    <div class="shop-desc" id="shop-desc-3"></div>
                    <button class="shop-buy-btn" id="shop-buy-3" disabled>--</button>
                </div>
                <div class="shop-item-wrapper" id="shop-wrapper-4">
                    <div class="shop-name" id="shop-name-4"></div>
                    <div class="shop-desc" id="shop-desc-4"></div>
                    <button class="shop-buy-btn" id="shop-buy-4" disabled>--</button>
                </div>
            </div>
        </div>

        <div class="panel-nav" id="panel-nav">
        </div>
    </div>

    <div class="chat-panel">
        <div class="chat-messages" id="chat-messages">
            <!-- Messages appear here -->
            <div class="action-panel">   <!-- Edit by me -->
        </div>
    </div>

    <div class="modal-overlay" id="save-modal">
        <div class="modal">
            <h3>[ SAVE SLOTS ]</h3>
            <div class="save-slot" id="slot-1">
                <div class="save-slot-header">
                    <span class="save-slot-title">Slot 1</span>
                </div>
                <div class="save-slot-info" id="slot-1-info">
                    <span class="save-slot-empty">-- Empty --</span>
                </div>
                <div class="save-slot-actions">
                    <button class="slot-btn load" id="slot-1-load" onclick="loadFromSlot(1)">Load</button>
                    <button class="slot-btn delete" id="slot-1-delete" onclick="deleteSlot(1)" disabled>Delete</button>
                    <button class="slot-btn boost-xp" id="slot-1-boost" onclick="boostSlotXp(1)" disabled>+Si</button>
                </div>
            </div>
            <div class="save-slot" id="slot-2">
                <div class="save-slot-header">
                    <span class="save-slot-title">Slot 2</span>
                </div>
                <div class="save-slot-info" id="slot-2-info">
                    <span class="save-slot-empty">-- Empty --</span>
                </div>
                <div class="save-slot-actions">
                    <button class="slot-btn load" id="slot-2-load" onclick="loadFromSlot(2)">Load</button>
                    <button class="slot-btn delete" id="slot-2-delete" onclick="deleteSlot(2)" disabled>Delete</button>
                    <button class="slot-btn boost-xp" id="slot-2-boost" onclick="boostSlotXp(2)" disabled>+Si</button>
                </div>
            </div>
            <div class="save-slot" id="slot-3">
                <div class="save-slot-header">
                    <span class="save-slot-title">Slot 3</span>
                </div>
                <div class="save-slot-info" id="slot-3-info">
                    <span class="save-slot-empty">-- Empty --</span>
                </div>
                <div class="save-slot-actions">
                    <button class="slot-btn load" id="slot-3-load" onclick="loadFromSlot(3)">Load</button>
                    <button class="slot-btn delete" id="slot-3-delete" onclick="deleteSlot(3)" disabled>Delete</button>
                    <button class="slot-btn boost-xp" id="slot-3-boost" onclick="boostSlotXp(3)" disabled>+Si</button>
                </div>
            </div>
            <button class="modal-close" id="modal-close">Close</button>
        </div>
    </div>

    <div class="confirm-overlay" id="confirm-delete-modal">
        <div class="confirm-box">
            <p>Are you sure you want to delete?</p>
            <div class="confirm-actions">
                <button class="confirm-btn yes" id="confirm-delete-yes">Yes</button>
                <button class="confirm-btn no" id="confirm-delete-no">No</button>
            </div>
        </div>
    </div>

    <script src="enemies_scrapyard.js"></script>
    <script src="enemies_oldbattlefield.js"></script>
    <script src="enemies_downtown.js"></script>
    <script src="enemies_orbitalstation.js"></script>
    <script src="enemies_wasteland.js"></script>
    <script src="enemies_undercity.js"></script>
    <script src="enemies_industrialzone.js"></script>
    <script src="enemies_frozenreach.js"></script>
    <script src="enemies_neonstrip.js"></script>
    <script src="enemies_deadzone.js"></script>
    <script src="enemies_frontline.js"></script>
    <script src="enemies_ratpile.js"></script>
    <script src="ambush_ratpile.js"></script>
    <script src="ambush_scrapyard.js"></script>
    <script src="ambush_oldbattlefield.js"></script>
    <script src="ambush_downtown.js"></script>
    <script src="ambush_orbitalstation.js"></script>
    <script src="ambush_wasteland.js"></script>
    <script src="ambush_undercity.js"></script>
    <script src="ambush_industrialzone.js"></script>
    <script src="ambush_frozenreach.js"></script>
    <script src="ambush_neonstrip.js"></script>
    <script src="ambush_deadzone.js"></script>
    <script src="ambush_frontline.js"></script>
    <script src="boss_encounters.js"></script>
    <script src="items.js"></script>
    <script src="pilots.js"></script>
    <script>ITEMS.push(...ALL_PILOTS);</script>
    <script src="storyitems.js"></script>
    <script src="encounters_home.js"></script>
    <script src="encounters_forge.js"></script>
    <script src="encounters_guild.js"></script>
    <script src="encounters_salvageyard.js"></script>
    <script src="encounters_decrypter.js"></script>
    <script src="encounters_ratpile.js"></script>
    <script src="encounters_scrapyard.js"></script>
    <script src="encounters_oldbattlefield.js"></script>
    <script src="encounters_downtown.js"></script>
    <script src="encounters_orbitalstation.js"></script>
    <script src="encounters_wasteland.js"></script>
    <script src="encounters_undercity.js"></script>
    <script src="encounters_industrialzone.js"></script>
    <script src="encounters_frozenreach.js"></script>
    <script src="encounters_neonstrip.js"></script>
    <script src="encounters_deadzone.js"></script>
    <script src="encounters_frontline.js"></script>
    <script src="mining_scrapyard.js"></script>
    <script src="mining_oldbattlefield.js"></script>
    <script src="mining_downtown.js"></script>
    <script src="mining_orbitalstation.js"></script>
    <script src="mining_wasteland.js"></script>
    <script src="mining_undercity.js"></script>
    <script src="mining_industrialzone.js"></script>
    <script src="mining_frozenreach.js"></script>
    <script src="mining_neonstrip.js"></script>
    <script src="mining_deadzone.js"></script>
    <script src="mining_asteroidbelt.js"></script>
    <script src="refined_minerals.js"></script>
    <script src="forger_items.js"></script>
    <script>
        // Game State
        const game = {
            player: {
                // Base stats (without equipment)
                baseMaxHp: 100,
                baseAttack: 0,
                baseSpeed: 0,
                baseDefence: 0,
                baseBreaker: 0,
                baseMining: 0,
                baseRegen: 0,
                // Current stats (with equipment)
                level: 1,
                xp: 0,
                xpToLevel: 10,
                maxHp: 100,
                hp: 100,
                attack: 0,
                speed: 0,
                defence: 0,
                breaker: 0,
                mining: 0,
                regen: 0,
                fuel: 100,
                maxFuel: 100
            },
            // Inventory: array of item objects
            inventory: [],
            // Equipped items by slot (stores item name or null)
            equipment: {
                body: null,
                legs: null,
                arms: null,
                weapon: null,
                chip: null,
                processor: null,
                pilot: null,
                drill: null,
                implant: null
            },
            currentWave: null,
            inBattle: false,
            battleInterval: null,
            regenInterval: null,
            fuelRegenInterval: null,
            waveTimer: null,
            nextWaveTime: 0,
            waveExpireTimer: null,
            WAVE_INTERVAL: 5000, // 5 seconds wait
            WAVE_EXPIRE: 30000, // 30 seconds to engage
            countdownInterval: null,
            countdownMsg: null,
            ENCOUNTER_CHANCE: 20, // % chance for encounter instead of enemy wave
            deaths: 0,
            scrap: 0,
            activeSlot: null, // Which save slot is currently active (1-3 or null)
            minerals: {}, // Collected minerals by category
            storyItems: ['Mysterious Note', 'Unknown Sealed Key', 'Unreadable DNA Tag', 'Destroyed Mech Heart'], // Collected story items
            isAmbush: false, // Whether current wave is an ambush
            isBossEncounter: false // Whether current wave is a boss encounter
        };

        // Current encounter state
        let currentEncounter = null;
        let shopItems = [];
        let currentMiningEvent = null;
        let currentBossEncounter = null; // Active boss encounter data

        const MINING_CHANCE = 15; // % chance for mining event instead of enemy wave
        const AMBUSH_CHANCE = 10; // % chance for ambush instead of normal enemy wave
        const BOSS_CHANCE = 50; // % chance for boss encounter instead of normal enemy wave

        const SAVE_KEY = 'combobreaker_save';
        const SLOT_KEYS = ['combobreaker_slot_1', 'combobreaker_slot_2', 'combobreaker_slot_3'];

        // Build save data object from current game state
        function buildSaveData() {
            return {
                version: '1.1.0',
                player: {
                    level: game.player.level,
                    xp: game.player.xp,
                    xpToLevel: game.player.xpToLevel,
                    baseMaxHp: game.player.baseMaxHp,
                    baseAttack: game.player.baseAttack,
                    baseSpeed: game.player.baseSpeed,
                    baseDefence: game.player.baseDefence,
                    baseBreaker: game.player.baseBreaker,
                    baseMining: game.player.baseMining,
                    baseRegen: game.player.baseRegen
                },
                inventory: game.inventory.map(item => item.name),
                equipment: { ...game.equipment },
                fuel: game.player.fuel,
                deaths: game.deaths,
                scrap: game.scrap || 0,
                activeSlot: game.activeSlot,
                location: currentLocation,
                destination: currentDestination || 'openworld',
                minerals: game.minerals || {},
                storyItems: game.storyItems || [],
                forgedItems: [...FORGER_ITEMS]
            };
        }

        // Get slot data from localStorage (returns parsed object or null)
        function getSlotData(slotNum) {
            try {
                const raw = localStorage.getItem(SLOT_KEYS[slotNum - 1]);
                return raw ? JSON.parse(raw) : null;
            } catch (e) {
                return null;
            }
        }

        // Grant +1000 Silicon to a save slot (tester tool)
        function boostSlotXp(slotNum) {
            const data = getSlotData(slotNum);
            if (!data || !data.player) return;
            data.player.xp = (data.player.xp || 0) + 1000;
            localStorage.setItem(SLOT_KEYS[slotNum - 1], JSON.stringify(data));
            // If this is the active slot, also update live game state
            if (game.activeSlot === slotNum) {
                game.player.xp = data.player.xp;
                recalculateStats();
                updateStats();
            }
            refreshSlotDisplays();
        }

        // Refresh all slot displays in the modal
        function refreshSlotDisplays() {
            for (let i = 1; i <= 3; i++) {
                const data = getSlotData(i);
                const slotEl = document.getElementById(`slot-${i}`);
                const titleEl = slotEl.querySelector('.save-slot-title');
                const infoEl = document.getElementById(`slot-${i}-info`);
                const loadBtn = document.getElementById(`slot-${i}-load`);
                const deleteBtn = document.getElementById(`slot-${i}-delete`);
                const boostBtn = document.getElementById(`slot-${i}-boost`);
                const isActive = game.activeSlot === i;

                // Highlight active slot
                slotEl.classList.toggle('active', isActive);
                titleEl.textContent = isActive ? `Slot ${i} [ACTIVE]` : `Slot ${i}`;

                if (data && data.player) {
                    const p = data.player;
                    infoEl.innerHTML =
                        `Level: <span>${p.level}</span> | ` +
                        `Silicon: <span>${p.xp || 0}/${p.xpToLevel || 10}</span> | ` +
                        `HP: <span>${p.baseMaxHp}</span> | ` +
                        `ATK: <span>${p.baseAttack}</span> | ` +
                        `SPD: <span>${p.baseSpeed}</span> | ` +
                        `DEF: <span>${p.baseDefence}</span><br>` +
                        `Breaker: <span>${p.baseBreaker}%</span> | ` +
                        `Deaths: <span>${data.deaths || 0}</span> | ` +
                        `Items: <span>${(data.inventory || []).length}</span>`;
                    loadBtn.style.display = '';
                    loadBtn.disabled = false;
                    deleteBtn.disabled = false;
                    boostBtn.disabled = false;
                    // Hide new game button if it exists
                    let ngBtn = document.getElementById(`slot-${i}-new`);
                    if (ngBtn) ngBtn.style.display = 'none';
                } else {
                    infoEl.innerHTML = '<span class="save-slot-empty">-- Empty --</span>';
                    loadBtn.style.display = 'none';
                    deleteBtn.disabled = true;
                    boostBtn.disabled = true;
                    // Show new game button
                    let ngBtn = document.getElementById(`slot-${i}-new`);
                    if (!ngBtn) {
                        ngBtn = document.createElement('button');
                        ngBtn.id = `slot-${i}-new`;
                        ngBtn.className = 'slot-btn new-game';
                        ngBtn.textContent = 'New Game';
                        ngBtn.onclick = () => newGame(i);
                        loadBtn.parentNode.insertBefore(ngBtn, loadBtn);
                    }
                    ngBtn.style.display = '';
                }
            }
        }

        // Start a new game on an empty slot
        function newGame(slotNum) {
            game.activeSlot = slotNum;

            // Stop all active timers and battle state
            game.inBattle = false;
            game.currentWave = null;
            game.isAmbush = false;
            game.isBossEncounter = false;
            currentBossEncounter = null;
            currentEncounter = null;
            currentMiningEvent = null;
            shopItems = [];
            if (game.battleInterval) { clearInterval(game.battleInterval); game.battleInterval = null; }
            if (game.regenInterval) { clearInterval(game.regenInterval); game.regenInterval = null; }
            if (game.fuelRegenInterval) { clearInterval(game.fuelRegenInterval); game.fuelRegenInterval = null; }
            if (game.waveTimer) { clearInterval(game.waveTimer); game.waveTimer = null; }
            if (game.waveExpireTimer) { clearTimeout(game.waveExpireTimer); game.waveExpireTimer = null; }
            clearCountdown();

            // Fresh start stats
            game.player.level = 1;
            game.player.xp = 0;
            game.player.xpToLevel = 10;
            game.player.baseMaxHp = 100;
            game.player.baseAttack = 0;
            game.player.baseSpeed = 0;
            game.player.baseDefence = 0;
            game.player.baseBreaker = 0;
            game.player.baseMining = 0;
            game.player.baseRegen = 0;
            game.player.fuel = 100;
            game.deaths = 0;
            game.scrap = 0;
            game.minerals = {};
            game.storyItems = ['Mysterious Note', 'Unknown Sealed Key', 'Unreadable DNA Tag', 'Destroyed Mech Heart'];
            game.inventory = [];
            game.equipment = { body: null, legs: null, arms: null, weapon: null, chip: null, processor: null, pilot: null, drill: null, implant: null, mindsync: null };
            currentLocation = 'home';
            currentDestination = 'openworld';

            // Update location UI
            updateLocationDropdown();
            updateDestinationDropdown();
            document.getElementById('location-select').value = currentLocation;
            document.getElementById('location-image').src = LOCATIONS[currentLocation].image;
            document.getElementById('location-desc').innerHTML = `<div class="storage-desc-content"><img src="${LOCATIONS[currentLocation].image}" alt="Location"><span>${LOCATIONS[currentLocation].desc}</span></div>`;

            recalculateStats();
            game.player.hp = game.player.maxHp;
            updateEquipmentUI();
            updateMiningUI();
            updateStorageUI();
            updateStats();
            saveGame();

            // Reset UI: clear chat, reset page, disable buttons
            chatMessages.innerHTML = '';
            storeAvailable = false;
            showPage(0);
            setEquipmentLocked(false);
            hideInlineButtons();

            // Close modal and notify
            document.getElementById('save-modal').classList.remove('visible');
            addMessage(`[NEW GAME - SLOT ${slotNum}]`, 'system');
            startFuelRegen();

            // Start wave cycle
            setTimeout(() => {
                spawnWave();
                startWaveTimer();
            }, 2000);
        }

        // Load game from a slot
        function loadFromSlot(slotNum) {
            const data = getSlotData(slotNum);
            game.activeSlot = slotNum;

            // Stop all active timers and battle state
            game.inBattle = false;
            game.currentWave = null;
            game.isAmbush = false;
            game.isBossEncounter = false;
            currentBossEncounter = null;
            currentEncounter = null;
            currentMiningEvent = null;
            shopItems = [];
            if (game.battleInterval) { clearInterval(game.battleInterval); game.battleInterval = null; }
            if (game.regenInterval) { clearInterval(game.regenInterval); game.regenInterval = null; }
            if (game.fuelRegenInterval) { clearInterval(game.fuelRegenInterval); game.fuelRegenInterval = null; }
            if (game.waveTimer) { clearInterval(game.waveTimer); game.waveTimer = null; }
            if (game.waveExpireTimer) { clearTimeout(game.waveExpireTimer); game.waveExpireTimer = null; }
            clearCountdown();

            if (!data || !data.player) return; // Empty slots use newGame() instead

            // Restore player base stats
            game.player.level = data.player.level !== undefined ? data.player.level : 1;
            game.player.xp = data.player.xp || 0;
            game.player.xpToLevel = data.player.xpToLevel || 10;
            game.player.baseMaxHp = data.player.baseMaxHp !== undefined ? data.player.baseMaxHp : 100;
            game.player.baseAttack = data.player.baseAttack !== undefined ? data.player.baseAttack : 0;
            game.player.baseSpeed = data.player.baseSpeed !== undefined ? data.player.baseSpeed : 0;
            game.player.baseDefence = data.player.baseDefence !== undefined ? data.player.baseDefence : 0;
            game.player.baseBreaker = data.player.baseBreaker !== undefined ? data.player.baseBreaker : (data.player.baseCombo !== undefined ? data.player.baseCombo : 0);
            game.player.baseMining = data.player.baseMining !== undefined ? data.player.baseMining : 0;
            game.player.baseRegen = data.player.baseRegen !== undefined ? data.player.baseRegen : 0;

            game.player.fuel = data.fuel !== undefined ? data.fuel : 100;
            game.deaths = data.deaths || 0;
            game.scrap = data.scrap || 0;
            game.minerals = data.minerals || {};
            game.storyItems = data.storyItems && data.storyItems.length > 0 ? data.storyItems : ['Mysterious Note', 'Unknown Sealed Key', 'Unreadable DNA Tag', 'Destroyed Mech Heart'];

            // Restore location
            if (data.location && LOCATIONS[data.location]) {
                currentLocation = data.location;
            } else {
                currentLocation = 'scrapyard';
            }

            // Restore forged items registry before inventory lookup
            restoreForgedItems(data.forgedItems);

            // Restore inventory
            game.inventory = [];
            if (data.inventory && Array.isArray(data.inventory)) {
                data.inventory.forEach(itemName => {
                    const item = ITEMS.find(i => i.name === itemName) || FORGER_ITEMS.find(i => i.name === itemName);
                    if (item) game.inventory.push(item);
                });
            }

            // Restore equipment
            if (data.equipment) {
                game.equipment = {
                    body: data.equipment.body || null,
                    legs: data.equipment.legs || null,
                    arms: data.equipment.arms || null,
                    weapon: data.equipment.weapon || null,
                    chip: data.equipment.chip || null,
                    processor: data.equipment.processor || null,
                    pilot: data.equipment.pilot || null,
                    drill: data.equipment.drill || null,
                    implant: data.equipment.implant || null,
                    mindsync: data.equipment.mindsync || null
                };
            }

            currentDestination = 'openworld';

            // Update location UI
            updateLocationDropdown();
            updateDestinationDropdown();
            document.getElementById('location-select').value = currentLocation;
            document.getElementById('location-image').src = LOCATIONS[currentLocation].image;
            document.getElementById('location-desc').innerHTML = `<div class="storage-desc-content"><img src="${LOCATIONS[currentLocation].image}" alt="Location"><span>${LOCATIONS[currentLocation].desc}</span></div>`;

            recalculateStats();
            game.player.hp = game.player.maxHp;
            updateEquipmentUI();
            updateMiningUI();
            updateStorageUI();
            updateStats();
            saveGame();

            // Reset UI: clear chat, reset page, disable buttons
            chatMessages.innerHTML = '';
            storeAvailable = false;
            showPage(0);
            setEquipmentLocked(false);
            hideInlineButtons();

            // Close modal and notify
            document.getElementById('save-modal').classList.remove('visible');
            addMessage(`[SLOT ${slotNum} LOADED] Level ${game.player.level} restored.`, 'system');
            startFuelRegen();

            // Restart wave cycle
            setTimeout(() => {
                spawnWave();
                startWaveTimer();
            }, 2000);
        }

        // Delete a save slot (with confirmation)
        let pendingDeleteSlot = null;

        function deleteSlot(slotNum) {
            pendingDeleteSlot = slotNum;
            document.getElementById('confirm-delete-modal').classList.add('visible');
        }

        document.getElementById('confirm-delete-yes').addEventListener('click', () => {
            if (pendingDeleteSlot !== null) {
                localStorage.removeItem(SLOT_KEYS[pendingDeleteSlot - 1]);
                if (game.activeSlot === pendingDeleteSlot) {
                    game.activeSlot = null;
                }
                refreshSlotDisplays();
                pendingDeleteSlot = null;
            }
            document.getElementById('confirm-delete-modal').classList.remove('visible');
        });

        document.getElementById('confirm-delete-no').addEventListener('click', () => {
            pendingDeleteSlot = null;
            document.getElementById('confirm-delete-modal').classList.remove('visible');
        });

        // Save game state to localStorage
        function saveGame() {
            const saveData = buildSaveData();

            try {
                localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
                // Also update the active slot so its displayed stats stay current
                if (game.activeSlot) {
                    localStorage.setItem(SLOT_KEYS[game.activeSlot - 1], JSON.stringify(saveData));
                }
                showSaveIndicator();
            } catch (e) {
                console.error('Failed to save game:', e);
            }
        }

        // Load game state from localStorage
        function loadGame() {
            try {
                const savedData = localStorage.getItem(SAVE_KEY);
                if (!savedData) return false;

                const data = JSON.parse(savedData);

                // Restore player base stats and progression
                game.player.level = data.player.level !== undefined ? data.player.level : 1;
                game.player.xp = data.player.xp || 0;
                game.player.xpToLevel = data.player.xpToLevel || 10;
                game.player.baseMaxHp = data.player.baseMaxHp !== undefined ? data.player.baseMaxHp : 100;
                game.player.baseAttack = data.player.baseAttack !== undefined ? data.player.baseAttack : 0;
                game.player.baseSpeed = data.player.baseSpeed !== undefined ? data.player.baseSpeed : 0;
                game.player.baseDefence = data.player.baseDefence !== undefined ? data.player.baseDefence : 0;
                game.player.baseBreaker = data.player.baseBreaker !== undefined ? data.player.baseBreaker : (data.player.baseCombo !== undefined ? data.player.baseCombo : 0);
                game.player.baseMining = data.player.baseMining !== undefined ? data.player.baseMining : 0;
                game.player.baseRegen = data.player.baseRegen !== undefined ? data.player.baseRegen : 0;

                // Restore death counter, active slot, fuel, and minerals
                game.player.fuel = data.fuel !== undefined ? data.fuel : 100;
                game.deaths = data.deaths || 0;
                game.scrap = data.scrap || 0;
                game.activeSlot = data.activeSlot || null;
                game.minerals = data.minerals || {};
                game.storyItems = data.storyItems && data.storyItems.length > 0 ? data.storyItems : ['Mysterious Note', 'Unknown Sealed Key', 'Unreadable DNA Tag', 'Destroyed Mech Heart'];

                // Restore location
                if (data.location && LOCATIONS[data.location]) {
                    currentLocation = data.location;
                }
                currentDestination = data.destination || 'openworld';
                updateLocationDropdown();
                updateDestinationDropdown();
                document.getElementById('location-select').value = currentLocation;
                document.getElementById('destination-select').value = currentDestination;
                document.getElementById('location-image').src = LOCATIONS[currentLocation].image;
                document.getElementById('location-desc').innerHTML = `<div class="storage-desc-content"><img src="${LOCATIONS[currentLocation].image}" alt="Location"><span>${LOCATIONS[currentLocation].desc}</span></div>`;

                // Restore forged items registry before inventory lookup
                restoreForgedItems(data.forgedItems);

                // Restore inventory (convert names back to item objects)
                game.inventory = [];
                if (data.inventory && Array.isArray(data.inventory)) {
                    data.inventory.forEach(itemName => {
                        const item = ITEMS.find(i => i.name === itemName) || FORGER_ITEMS.find(i => i.name === itemName);
                        if (item) {
                            game.inventory.push(item);
                        }
                    });
                }

                // Restore equipment
                if (data.equipment) {
                    game.equipment = {
                        body: data.equipment.body || null,
                        legs: data.equipment.legs || null,
                        arms: data.equipment.arms || null,
                        weapon: data.equipment.weapon || null,
                        chip: data.equipment.chip || null,
                        processor: data.equipment.processor || null,
                        pilot: data.equipment.pilot || null,
                        drill: data.equipment.drill || null,
                        implant: data.equipment.implant || null,
                        mindsync: data.equipment.mindsync || null
                    };
                }

                return true;
            } catch (e) {
                console.error('Failed to load game:', e);
                return false;
            }
        }

        // Show save indicator briefly
        function showSaveIndicator() {
            const indicator = document.getElementById('save-indicator');
            indicator.classList.add('visible');
            setTimeout(() => {
                indicator.classList.remove('visible');
            }, 1500);
        }

        // DOM Elements
        const chatMessages = document.getElementById('chat-messages');
        const timerDisplay = document.getElementById('timer-display');

        // Create action buttons (inserted into chat flow dynamically)
        const btnContainer = document.createElement('div');
        btnContainer.className = 'action-btn-container';
        const btnEngage = document.createElement('button');
        btnEngage.className = 'action-btn engage';
        btnEngage.id = 'btn-engage';
        btnEngage.disabled = true;
        btnEngage.textContent = 'Engage';
        const btnRetreat = document.createElement('button');
        btnRetreat.className = 'action-btn retreat';
        btnRetreat.id = 'btn-retreat';
        btnRetreat.disabled = true;
        btnRetreat.textContent = 'Decline';
        btnContainer.appendChild(btnEngage);
        btnContainer.appendChild(btnRetreat);

        // Panel page navigation
        const PAGES = [
            { id: 'page-stats', label: 'Stats', icon: 'images/STATS.gif' },        // 0
            { id: 'page-installations', label: 'Installations', icon: 'images/INSTALLATIONS.gif' }, // 1
            { id: 'page-pilot', label: 'Pilot', icon: 'images/PILOT.gif' },         // 2
            { id: 'page-location', label: 'Location', icon: 'images/LOCATION.gif' },   // 3
            { id: 'page-mining', label: 'Mining', icon: 'images/MINING.gif' },        // 4
            { id: 'page-storage', label: 'Storage', icon: 'images/STORAGE.gif' },     // 5
            { id: 'page-store', label: 'Store', icon: 'images/STORE.gif' }           // 6
        ];
        let currentPage = 0;
        let storeAvailable = false;

        // Build nav icons
        const panelNav = document.getElementById('panel-nav');
        PAGES.forEach((page, i) => {
            const iconDiv = document.createElement('div');
            iconDiv.className = 'nav-icon';
            iconDiv.id = `nav-icon-${i}`;
            iconDiv.title = page.label;
            const img = document.createElement('img');
            img.src = page.icon;
            img.alt = page.label;
            iconDiv.appendChild(img);
            iconDiv.addEventListener('click', () => showPage(i));
            panelNav.appendChild(iconDiv);
        });
        // Set initial active state and hide store icon
        document.getElementById('nav-icon-0').classList.add('active');
        document.getElementById('nav-icon-6').classList.add('hidden');

        function getAvailablePages() {
            if (storeAvailable) return [0, 1, 2, 3, 4, 5, 6];
            return [0, 1, 2, 3, 4, 5];
        }

        function updatePanelNav() {
            const available = getAvailablePages();
            PAGES.forEach((p, i) => {
                const icon = document.getElementById(`nav-icon-${i}`);
                if (!icon) return;
                icon.classList.toggle('active', i === currentPage);
                icon.classList.toggle('hidden', !available.includes(i));
            });
        }

        function showPage(pageIndex) {
            PAGES.forEach((p, i) => {
                document.getElementById(p.id).classList.toggle('active', i === pageIndex);
            });
            currentPage = pageIndex;
            updatePanelNav();
        }

        // Location system
        const LOCATIONS = {
            ratpile: {
                enemies: ENEMIES_RATPILE,
                encounters: ENCOUNTERS_RATPILE,
                mining: null,
                ambush: AMBUSH_RATPILE,
                fuelCost: 0,
                desc: "A festering nest of silicon rats beneath the scrapyard. Weak vermin, but they never stop coming.",
                image: "images/IMAGE.gif"
            },
            scrapyard: {
                enemies: ENEMIES_SCRAPYARD,
                encounters: ENCOUNTERS_SCRAPYARD,
                mining: MINING_SCRAPYARD,
                ambush: AMBUSH_SCRAPYARD,
                fuelCost: 5,
                desc: "Piles of rusted mechs and salvageable parts. Low-threat scavenger bots roam the wreckage.",
                image: "images/IMAGE.gif"
            },
            oldbattlefield: {
                enemies: ENEMIES_OLDBATTLEFIELD,
                encounters: ENCOUNTERS_OLDBATTLEFIELD,
                mining: MINING_OLDBATTLEFIELD,
                ambush: AMBUSH_OLDBATTLEFIELD,
                fuelCost: 10,
                desc: "Scarred terrain littered with war machines still running combat protocols from a forgotten conflict.",
                image: "images/IMAGE.gif"
            },
            downtown: {
                enemies: ENEMIES_DOWNTOWN,
                encounters: ENCOUNTERS_DOWNTOWN,
                mining: MINING_DOWNTOWN,
                ambush: AMBUSH_DOWNTOWN,
                fuelCost: 15,
                desc: "Neon-lit urban sprawl. Corporate security and street-modded combat rigs patrol the blocks.",
                image: "images/IMAGE.gif"
            },
            orbitalstation: {
                enemies: ENEMIES_ORBITALSTATION,
                encounters: ENCOUNTERS_ORBITALSTATION,
                mining: MINING_ORBITALSTATION,
                ambush: AMBUSH_ORBITALSTATION,
                fuelCost: 20,
                desc: "A derelict orbital platform. Rogue drones and hijacked defense systems stalk the corridors.",
                image: "images/IMAGE.gif"
            },
            wasteland: {
                enemies: ENEMIES_WASTELAND,
                encounters: ENCOUNTERS_WASTELAND,
                mining: MINING_WASTELAND,
                ambush: AMBUSH_WASTELAND,
                fuelCost: 25,
                desc: "Irradiated badlands where feral war machines and dust-choked scavengers fight over scraps.",
                image: "images/IMAGE.gif"
            },
            undercity: {
                enemies: ENEMIES_UNDERCITY,
                encounters: ENCOUNTERS_UNDERCITY,
                mining: MINING_UNDERCITY,
                ambush: AMBUSH_UNDERCITY,
                fuelCost: 30,
                desc: "A labyrinth of tunnels and sewers beneath the streets. Black-ops units and tunnel rats lurk in the dark.",
                image: "images/IMAGE.gif"
            },
            industrialzone: {
                enemies: ENEMIES_INDUSTRIALZONE,
                encounters: ENCOUNTERS_INDUSTRIALZONE,
                mining: MINING_INDUSTRIALZONE,
                ambush: AMBUSH_INDUSTRIALZONE,
                fuelCost: 35,
                desc: "Sprawling factories and refineries. Malfunctioning production bots guard the assembly lines.",
                image: "images/IMAGE.gif"
            },
            frozenreach: {
                enemies: ENEMIES_FROZENREACH,
                encounters: ENCOUNTERS_FROZENREACH,
                mining: MINING_FROZENREACH,
                ambush: AMBUSH_FROZENREACH,
                fuelCost: 40,
                desc: "Arctic tundra locked in permanent winter. Cryo-adapted war machines patrol the frozen expanse.",
                image: "images/IMAGE.gif"
            },
            neonstrip: {
                enemies: ENEMIES_NEONSTRIP,
                encounters: ENCOUNTERS_NEONSTRIP,
                mining: MINING_NEONSTRIP,
                ambush: AMBUSH_NEONSTRIP,
                fuelCost: 45,
                desc: "The flashy entertainment district. Syndicate enforcers and casino muscle keep the peace their way.",
                image: "images/IMAGE.gif"
            },
            deadzone: {
                enemies: ENEMIES_DEADZONE,
                encounters: ENCOUNTERS_DEADZONE,
                mining: MINING_DEADZONE,
                ambush: AMBUSH_DEADZONE,
                fuelCost: 50,
                desc: "Heavily contaminated killing fields. Corrupted AI and mutated war platforms roam unchecked.",
                image: "images/IMAGE.gif"
            },
            asteroidbelt: {
                enemies: null,
                encounters: null,
                mining: MINING_ASTEROIDBELT,
                ambush: null,
                fuelCost: 30,
                desc: "A dense field of mineral-rich asteroids. No hostiles, no traders  just rock, ore, and the void.",
                image: "images/IMAGE.gif"
            },
            frontline: {
                enemies: ENEMIES_FRONTLINE,
                encounters: ENCOUNTERS_FRONTLINE,
                mining: null,
                ambush: AMBUSH_FRONTLINE,
                fuelCost: 55,
                desc: "Active military staging ground. Squadrons of piloted combobreakers hold the line. They killed you once.",
                image: "images/IMAGE.gif"
            },
            morningstar: {
                enemies: null,
                encounters: null,
                mining: null,
                ambush: null,
                fuelCost: 100,
                desc: "Past the frontline. Past the war. Morningstar is here  a monolithic war machine that hasn't stopped advancing in eighty years. The squad is with you. All of them. Finish it.",
                image: "images/IMAGE.gif"
            },
            forge: {
                enemies: null,
                encounters: ENCOUNTERS_FORGE,
                mining: null,
                ambush: null,
                fuelCost: 10,
                desc: "A hidden workshop built into an old munitions bunker. The air shimmers with heat from the forge.",
                image: "images/IMAGE.gif"
            },
            guild: {
                enemies: null,
                encounters: ENCOUNTERS_GUILD,
                mining: null,
                ambush: null,
                fuelCost: 10,
                desc: "A smoke-filled hall deep in the Undercity tunnels. Pilot dossiers cover every wall. Mercenaries for hire  no loyalty, no questions.",
                image: "images/IMAGE.gif"
            },
            salvageyard: {
                enemies: null,
                encounters: ENCOUNTERS_SALVAGEYARD,
                mining: null,
                ambush: null,
                fuelCost: 10,
                desc: "A mech chop-shop carved into an old freight depot. Hydraulic presses hiss and sparks fly from cutting torches.",
                image: "images/IMAGE.gif"
            },
            decrypter: {
                enemies: null,
                encounters: ENCOUNTERS_DECRYPTER,
                mining: null,
                ambush: null,
                fuelCost: 10,
                desc: "A sealed bunker humming with power. Banks of cipher machines line the walls. Someone is cracking codes.",
                image: "images/IMAGE.gif"
            },
            home: {
                enemies: null,
                encounters: ENCOUNTERS_HOME,
                mining: null,
                ambush: null,
                fuelCost: 0,
                desc: "Your workshop. The Professor is here, tinkering with salvage and offering what they've found.",
                image: "images/IMAGE.gif"
            }
        };

        let currentLocation = 'scrapyard';

        function getEnemies() {
            return LOCATIONS[currentLocation].enemies;
        }

        function getEncounters() {
            const allEncounters = LOCATIONS[currentLocation].encounters;
            if (!allEncounters) return null;

            // If at a named destination, return ONLY that encounter
            if (currentDestination && currentDestination !== 'openworld') {
                const enc = allEncounters.find(e => e.name === currentDestination);
                return enc ? [enc] : [];
            }

            // If at open world, filter OUT all discovered named encounters
            const zoneConfig = ZONE_DESTINATIONS[currentLocation];
            if (!zoneConfig) return allEncounters;

            return allEncounters.filter(enc => {
                const dest = zoneConfig.destinations.find(d => d.encounterName === enc.name);
                if (!dest) return true; // not discoverable, keep it
                // If discovered (player has location map), filter it OUT of open world
                return !(game.storyItems || []).includes(dest.mapItem);
            });
        }

        const LOCATION_NAMES = {
            ratpile: 'THE RATPILE',
            scrapyard: 'SCRAP FIELDS',
            oldbattlefield: 'OLD BATTLEFIELD',
            downtown: 'DOWNTOWN',
            orbitalstation: 'ORBITAL STATION',
            wasteland: 'WASTELAND',
            undercity: 'UNDERCITY',
            industrialzone: 'INDUSTRIAL ZONE',
            frozenreach: 'FROZEN REACH',
            neonstrip: 'NEON STRIP',
            deadzone: 'DEAD ZONE',
            asteroidbelt: 'ASTEROID BELT',
            frontline: 'THE FRONTLINE',
            morningstar: "MORNINGSTAR'S DESTRUCTION",
            forge: 'THE FORGE',
            guild: 'THE GUILD',
            salvageyard: 'MECH GRAVEYARD',
            decrypter: 'THE DECRYPTER',
            home: 'HOME'
        };

        // Map story item name to location key (ratpile and home are always unlocked)
        const LOCATION_MAP_ITEMS = {
            ratpile: 'Map: The Ratpile',
            scrapyard: 'Map: Scrap Fields',
            oldbattlefield: 'Map: Old Battlefield',
            downtown: 'Map: Downtown',
            orbitalstation: 'Map: Orbital Station',
            wasteland: 'Map: Wasteland',
            undercity: 'Map: Undercity',
            industrialzone: 'Map: Industrial Zone',
            guild: 'Map: The Guild',
            frozenreach: 'Map: Frozen Reach',
            neonstrip: 'Map: Neon Strip',
            deadzone: 'Map: Dead Zone',
            asteroidbelt: 'Map: Asteroid Belt',
            frontline: 'Map: Frontline',
            morningstar: 'Map: Morningstar\'s Destruction',
            forge: 'Map: The Forge',
            salvageyard: 'Map: Mech Graveyard',
            decrypter: 'Map: The Decrypter'
        };

        // Zone destinations: open world name + discoverable encounter locations per zone
        const ZONE_DESTINATIONS = {
            home: {
                openWorldName: null,
                openWorldDesc: null,
                destinations: [
                    { encounterName: "The Professor", mapItem: "Home: The Professor" }
                ]
            },
            ratpile: {
                openWorldName: "The Nests",
                openWorldDesc: "A sprawling field of corroded mech husks. Rats skitter between the rusted shells.",
                destinations: [
                    { encounterName: "The Mapmaker", mapItem: "The Ratpile: The Mapmaker" }
                ]
            },
            scrapyard: {
                openWorldName: "The Scrap Fields",
                openWorldDesc: "Endless piles of junked machinery stretching to the horizon. Scavenger bots pick through the wreckage.",
                destinations: [
                    { encounterName: "The Mapmaker", mapItem: "Scrap Fields: The Mapmaker" },
                    { encounterName: "Slag", mapItem: "Scrap Fields: Slag", destinationType: "refiner" },
                    { encounterName: "[COMMON] Mech Junker", mapItem: "Scrap Fields: Mech Junker" },
                    { encounterName: "[COMMON] Scrap Dealer", mapItem: "Scrap Fields: Scrap Dealer" },
                    { encounterName: "[COMMON] Field Mechanic", mapItem: "Scrap Fields: Field Mechanic" },
                    { encounterName: "[COMMON] Derelict Vending Array", mapItem: "Scrap Fields: Derelict Vending Array" },
                    { encounterName: "Aetherite Asteroid", mapItem: "Scrap Fields: Aetherite Asteroid" },
                    { encounterName: "Bronzewisp Asteroid", mapItem: "Scrap Fields: Bronzewisp Asteroid" },
                    { encounterName: "Cindergem Asteroid", mapItem: "Scrap Fields: Cindergem Asteroid" },
                    { encounterName: "The Herald", mapItem: "Scrap Fields: The Herald" },
                    { encounterName: "Rusted KV-8 Grinder", mapItem: "Scrap Fields: Rusted KV-8 Grinder" }
                ]
            },
            oldbattlefield: {
                openWorldName: "No Man's Land",
                openWorldDesc: "Scorched earth and shattered fortifications. War machines still patrol their forgotten routes.",
                destinations: [
                    { encounterName: "The Mapmaker", mapItem: "Old Battlefield: The Mapmaker" },
                    { encounterName: "Crucible", mapItem: "Old Battlefield: Crucible", destinationType: "refiner" },
                    { encounterName: "[COMMON] Salvage Auction Pod", mapItem: "Old Battlefield: Salvage Auction Pod" },
                    { encounterName: "[COMMON] Corporate Supply Cache", mapItem: "Old Battlefield: Corporate Supply Cache" },
                    { encounterName: "[COMMON] Pilgrim Parts Caravan", mapItem: "Old Battlefield: Pilgrim Parts Caravan" },
                    { encounterName: "[COMMON] Experimental R&D Vendor", mapItem: "Old Battlefield: Experimental R&D Vendor" },
                    { encounterName: "Duskquartz Asteroid", mapItem: "Old Battlefield: Duskquartz Asteroid" },
                    { encounterName: "Emberlith Asteroid", mapItem: "Old Battlefield: Emberlith Asteroid" },
                    { encounterName: "Frostveil Asteroid", mapItem: "Old Battlefield: Frostveil Asteroid" },
                    { encounterName: "The Herald", mapItem: "Old Battlefield: The Herald" },
                    { encounterName: "Shelled MK-IV Bulwark", mapItem: "Old Battlefield: Shelled MK-IV Bulwark" }
                ]
            },
            downtown: {
                openWorldName: "The Back Streets",
                openWorldDesc: "Neon-lit alleyways choked with smoke and static. Gang tags glow on every surface.",
                destinations: [
                    { encounterName: "The Mapmaker", mapItem: "Downtown: The Mapmaker" },
                    { encounterName: "Nyx", mapItem: "Downtown: Nyx", destinationType: "refiner" },
                    { encounterName: "[COMMON] Black Market Trader", mapItem: "Downtown: Black Market Trader" },
                    { encounterName: "[COMMON] Smuggler's Docking Bay", mapItem: "Downtown: Smuggler's Docking Bay" },
                    { encounterName: "[COMMON] Scrap Dealer", mapItem: "Downtown: Scrap Dealer" },
                    { encounterName: "[COMMON] Neon Bazaar Kiosk", mapItem: "Downtown: Neon Bazaar Kiosk" },
                    { encounterName: "Gloomstone Asteroid", mapItem: "Downtown: Gloomstone Asteroid" },
                    { encounterName: "Hexsilica Asteroid", mapItem: "Downtown: Hexsilica Asteroid" },
                    { encounterName: "Iridionite Asteroid", mapItem: "Downtown: Iridionite Asteroid" },
                    { encounterName: "The Herald", mapItem: "Downtown: The Herald" },
                    { encounterName: "Shadowed S-12 Wraith", mapItem: "Downtown: Shadowed S-12 Wraith" }
                ]
            },
            orbitalstation: {
                openWorldName: "Station Corridors",
                openWorldDesc: "Flickering emergency lights line depressurised hallways. Hull breaches whistle in the silence.",
                destinations: [
                    { encounterName: "The Mapmaker", mapItem: "Orbital Station: The Mapmaker" },
                    { encounterName: "Zero", mapItem: "Orbital Station: Zero", destinationType: "refiner" },
                    { encounterName: "[COMMON] Station Quartermaster", mapItem: "Orbital Station: Station Quartermaster" },
                    { encounterName: "[COMMON] Zero-G Peddler", mapItem: "Orbital Station: Zero-G Peddler" },
                    { encounterName: "[COMMON] Docking Ring Vendor", mapItem: "Orbital Station: Docking Ring Vendor" },
                    { encounterName: "[COMMON] Void Smuggler", mapItem: "Orbital Station: Void Smuggler" },
                    { encounterName: "Jetspinel Asteroid", mapItem: "Orbital Station: Jetspinel Asteroid" },
                    { encounterName: "Kryptoglass Asteroid", mapItem: "Orbital Station: Kryptoglass Asteroid" },
                    { encounterName: "Lumenore Asteroid", mapItem: "Orbital Station: Lumenore Asteroid" },
                    { encounterName: "The Herald", mapItem: "Orbital Station: The Herald" },
                    { encounterName: "Depressurized DR-7 Prospector", mapItem: "Orbital Station: Depressurized DR-7 Prospector" }
                ]
            },
            wasteland: {
                openWorldName: "The Dust Plains",
                openWorldDesc: "Irradiated badlands baking under a white sun. Heat mirages mask the predators.",
                destinations: [
                    { encounterName: "The Mapmaker", mapItem: "Wasteland: The Mapmaker" },
                    { encounterName: "Cinder", mapItem: "Wasteland: Cinder", destinationType: "refiner" },
                    { encounterName: "[COMMON] Nomad Trader", mapItem: "Wasteland: Nomad Trader" },
                    { encounterName: "[COMMON] Rad-Shielded Caravan", mapItem: "Wasteland: Rad-Shielded Caravan" },
                    { encounterName: "[COMMON] Scavenger Camp", mapItem: "Wasteland: Scavenger Camp" },
                    { encounterName: "[COMMON] Buried Supply Cache", mapItem: "Wasteland: Buried Supply Cache" },
                    { encounterName: "Moonshardite Asteroid", mapItem: "Wasteland: Moonshardite Asteroid" },
                    { encounterName: "Nightpyre Asteroid", mapItem: "Wasteland: Nightpyre Asteroid" },
                    { encounterName: "Obsidryl Asteroid", mapItem: "Wasteland: Obsidryl Asteroid" },
                    { encounterName: "The Herald", mapItem: "Wasteland: The Herald" },
                    { encounterName: "Irradiated AX-3 Ravager", mapItem: "Wasteland: Irradiated AX-3 Ravager" }
                ]
            },
            undercity: {
                openWorldName: "The Pipe Network",
                openWorldDesc: "A labyrinth of corroded pipes and flooded tunnels. Things move in the dark.",
                destinations: [
                    { encounterName: "The Mapmaker", mapItem: "Undercity: The Mapmaker" },
                    { encounterName: "Dreg", mapItem: "Undercity: Dreg", destinationType: "refiner" },
                    { encounterName: "[COMMON] Tunnel Fixer", mapItem: "Undercity: Tunnel Fixer" },
                    { encounterName: "[COMMON] Pipe Market Stall", mapItem: "Undercity: Pipe Market Stall" },
                    { encounterName: "[COMMON] Rogue Maintenance Drone", mapItem: "Undercity: Rogue Maintenance Drone" },
                    { encounterName: "[COMMON] Shadow Broker", mapItem: "Undercity: Shadow Broker" },
                    { encounterName: "Prismalune Asteroid", mapItem: "Undercity: Prismalune Asteroid" },
                    { encounterName: "Quellium Asteroid", mapItem: "Undercity: Quellium Asteroid" },
                    { encounterName: "Riftmarble Asteroid", mapItem: "Undercity: Riftmarble Asteroid" },
                    { encounterName: "The Herald", mapItem: "Undercity: The Herald" },
                    { encounterName: "Corroded SC-1 Flicker", mapItem: "Undercity: Corroded SC-1 Flicker" }
                ]
            },
            industrialzone: {
                openWorldName: "The Factory Floor",
                openWorldDesc: "Automated assembly lines still running with nothing to build. Sparks rain from overhead.",
                destinations: [
                    { encounterName: "The Mapmaker", mapItem: "Industrial Zone: The Mapmaker" },
                    { encounterName: "Anvil", mapItem: "Industrial Zone: Anvil", destinationType: "refiner" },
                    { encounterName: "[COMMON] Factory Surplus Outlet", mapItem: "Industrial Zone: Factory Surplus Outlet" },
                    { encounterName: "[COMMON] Union Supply Depot", mapItem: "Industrial Zone: Union Supply Depot" },
                    { encounterName: "[COMMON] Automated Vending Rig", mapItem: "Industrial Zone: Automated Vending Rig" },
                    { encounterName: "[COMMON] Shift Supervisor's Stash", mapItem: "Industrial Zone: Shift Supervisor's Stash" },
                    { encounterName: "Starvitrine Asteroid", mapItem: "Industrial Zone: Starvitrine Asteroid" },
                    { encounterName: "Thorncrystal Asteroid", mapItem: "Industrial Zone: Thorncrystal Asteroid" },
                    { encounterName: "Umbracite Asteroid", mapItem: "Industrial Zone: Umbracite Asteroid" },
                    { encounterName: "The Herald", mapItem: "Industrial Zone: The Herald" },
                    { encounterName: "Slag-Coated HG-6 Devastator", mapItem: "Industrial Zone: Slag-Coated HG-6 Devastator" }
                ]
            },
            frozenreach: {
                openWorldName: "The Ice Shelf",
                openWorldDesc: "A frozen expanse of cracked glaciers and buried wreckage. The wind cuts like a blade.",
                destinations: [
                    { encounterName: "The Mapmaker", mapItem: "Frozen Reach: The Mapmaker" },
                    { encounterName: "Thaw", mapItem: "Frozen Reach: Thaw", destinationType: "refiner" },
                    { encounterName: "[COMMON] Outpost Trader", mapItem: "Frozen Reach: Outpost Trader" },
                    { encounterName: "[COMMON] Ice Road Hauler", mapItem: "Frozen Reach: Ice Road Hauler" },
                    { encounterName: "[COMMON] Research Station Surplus", mapItem: "Frozen Reach: Research Station Surplus" },
                    { encounterName: "[COMMON] Glacier Prospector", mapItem: "Frozen Reach: Glacier Prospector" },
                    { encounterName: "Vortexium Asteroid", mapItem: "Frozen Reach: Vortexium Asteroid" },
                    { encounterName: "Wyrmstone Asteroid", mapItem: "Frozen Reach: Wyrmstone Asteroid" },
                    { encounterName: "Xanthryx Asteroid", mapItem: "Frozen Reach: Xanthryx Asteroid" },
                    { encounterName: "The Herald", mapItem: "Frozen Reach: The Herald" },
                    { encounterName: "Frozen MD-5 Lifeline", mapItem: "Frozen Reach: Frozen MD-5 Lifeline" }
                ]
            },
            neonstrip: {
                openWorldName: "The Main Drag",
                openWorldDesc: "A blinding corridor of holographic billboards and bass-heavy clubs. Violence is the entertainment.",
                destinations: [
                    { encounterName: "The Mapmaker", mapItem: "Neon Strip: The Mapmaker" },
                    { encounterName: "Glint", mapItem: "Neon Strip: Glint", destinationType: "refiner" },
                    { encounterName: "[COMMON] Back-Alley Dealer", mapItem: "Neon Strip: Back-Alley Dealer" },
                    { encounterName: "[COMMON] Casino Prize Counter", mapItem: "Neon Strip: Casino Prize Counter" },
                    { encounterName: "[COMMON] Syndicate Fence", mapItem: "Neon Strip: Syndicate Fence" },
                    { encounterName: "[COMMON] High-Roller Lounge", mapItem: "Neon Strip: High-Roller Lounge" },
                    { encounterName: "Yonderite Asteroid", mapItem: "Neon Strip: Yonderite Asteroid" },
                    { encounterName: "Zephyrsalt Asteroid", mapItem: "Neon Strip: Zephyrsalt Asteroid" },
                    { encounterName: "Isotope Lace Asteroid", mapItem: "Neon Strip: Isotope Lace Asteroid" },
                    { encounterName: "The Herald", mapItem: "Neon Strip: The Herald" },
                    { encounterName: "Gilded EN-9 Tinker", mapItem: "Neon Strip: Gilded EN-9 Tinker" }
                ]
            },
            deadzone: {
                openWorldName: "The Contamination Zone",
                openWorldDesc: "Toxic fog blankets everything. Corrupted machines wander in endless loops.",
                destinations: [
                    { encounterName: "The Mapmaker", mapItem: "Dead Zone: The Mapmaker" },
                    { encounterName: "Ash", mapItem: "Dead Zone: Ash", destinationType: "refiner" },
                    { encounterName: "[COMMON] Hazmat Trader", mapItem: "Dead Zone: Hazmat Trader" },
                    { encounterName: "[COMMON] Decontamination Drone", mapItem: "Dead Zone: Decontamination Drone" },
                    { encounterName: "[COMMON] Desperate Scavenger", mapItem: "Dead Zone: Desperate Scavenger" },
                    { encounterName: "[COMMON] Sealed Bunker Terminal", mapItem: "Dead Zone: Sealed Bunker Terminal" },
                    { encounterName: "Archive Shard Asteroid", mapItem: "Dead Zone: Archive Shard Asteroid" },
                    { encounterName: "Strata-Null Asteroid", mapItem: "Dead Zone: Strata-Null Asteroid" },
                    { encounterName: "Compound 33 Asteroid", mapItem: "Dead Zone: Compound 33 Asteroid" },
                    { encounterName: "The Herald", mapItem: "Dead Zone: The Herald" },
                    { encounterName: "Blighted EW-0 Phantom", mapItem: "Dead Zone: Blighted EW-0 Phantom" }
                ]
            },
            asteroidbelt: {
                openWorldName: "Asteroid Field",
                openWorldDesc: "A dense field of mineral-rich asteroids. Sensors ping with scattered mineral signatures.",
                destinationType: "mine",
                destinations: [
                    { encounterName: "Aetherite Asteroid", mapItem: "Asteroid Belt: Aetherite Asteroid" },
                    { encounterName: "Duskquartz Asteroid", mapItem: "Asteroid Belt: Duskquartz Asteroid" },
                    { encounterName: "Gloomstone Asteroid", mapItem: "Asteroid Belt: Gloomstone Asteroid" },
                    { encounterName: "Jetspinel Asteroid", mapItem: "Asteroid Belt: Jetspinel Asteroid" },
                    { encounterName: "Nightpyre Asteroid", mapItem: "Asteroid Belt: Nightpyre Asteroid" },
                    { encounterName: "Prismalune Asteroid", mapItem: "Asteroid Belt: Prismalune Asteroid" },
                    { encounterName: "Riftmarble Asteroid", mapItem: "Asteroid Belt: Riftmarble Asteroid" },
                    { encounterName: "Vortexium Asteroid", mapItem: "Asteroid Belt: Vortexium Asteroid" },
                    { encounterName: "Xanthryx Asteroid", mapItem: "Asteroid Belt: Xanthryx Asteroid" },
                    { encounterName: "Zephyrsalt Asteroid", mapItem: "Asteroid Belt: Zephyrsalt Asteroid" },
                    { encounterName: "Thorncrystal Asteroid", mapItem: "Asteroid Belt: Thorncrystal Asteroid" },
                    { encounterName: "Archive Shard Asteroid", mapItem: "Asteroid Belt: Archive Shard Asteroid" },
                    { encounterName: "Strata-Null Asteroid", mapItem: "Asteroid Belt: Strata-Null Asteroid" }
                ]
            },
            frontline: {
                openWorldName: "The Kill Corridor",
                openWorldDesc: "Military forward operating base. Piloted combobreakers patrol in tight formation. Every sensor is pointed at you.",
                destinations: [
                    { encounterName: "The Herald", mapItem: "Frontline: The Herald" }
                ]
            },
            morningstar: {
                openWorldName: "Morningstar's Position",
                openWorldDesc: "The end of the line. A monolithic war machine stands on scorched earth, facing you for the first time in eighty years.",
                destinations: []
            },
            forge: {
                openWorldName: null,
                openWorldDesc: null,
                destinations: [
                    { encounterName: "The Forger", mapItem: "The Forge: The Forger" }
                ]
            },
            guild: {
                openWorldName: null,
                openWorldDesc: null,
                destinations: [
                    { encounterName: "The Broker", mapItem: "The Guild: The Broker" }
                ]
            },
            salvageyard: {
                openWorldName: null,
                openWorldDesc: null,
                destinations: [
                    { encounterName: "Abandoned Monolith", mapItem: "Mech Graveyard: Abandoned Monolith" }
                ]
            }
        };

        // Track current destination within a zone ('openworld' or encounter name)
        let currentDestination = 'openworld';

        function updateLocationDropdown() {
            const select = document.getElementById('location-select');
            const current = select.value;
            select.innerHTML = '';

            for (const key in LOCATIONS) {
                // Ratpile and Home always available; others need a map
                const mapNeeded = LOCATION_MAP_ITEMS[key];
                if (mapNeeded && !(game.storyItems || []).includes(mapNeeded)) continue;

                const opt = document.createElement('option');
                opt.value = key;
                const fuelCost = LOCATIONS[key].fuelCost || 0;
                const fuelTag = fuelCost > 0 ? ` (${fuelCost} fuel)` : '';
                const friendZones = ['home', 'forge', 'guild', 'salvageyard'];
                const tag = friendZones.includes(key) ? '[FRIEND]' : '[ZONE]';
                opt.textContent = `${tag} ${LOCATION_NAMES[key] || key}${fuelTag}`;
                if (key === current) opt.selected = true;
                select.appendChild(opt);
            }
        }

        function updateDestinationDropdown() {
            const select = document.getElementById('destination-select');
            const current = select.value;
            select.innerHTML = '';

            const zoneConfig = ZONE_DESTINATIONS[currentLocation];

            // Add open world option (skip if zone has no open world, e.g. Home)
            if (!zoneConfig || zoneConfig.openWorldName) {
                const openWorldName = zoneConfig ? zoneConfig.openWorldName : (LOCATION_NAMES[currentLocation] || currentLocation);
                const owOpt = document.createElement('option');
                owOpt.value = 'openworld';
                owOpt.textContent = `[OPEN WORLD] ${openWorldName}`;
                select.appendChild(owOpt);
            }

            // Add discovered destinations
            if (zoneConfig) {
                for (const dest of zoneConfig.destinations) {
                    if ((game.storyItems || []).includes(dest.mapItem)) {
                        const opt = document.createElement('option');
                        opt.value = dest.encounterName;
                        const isMine = zoneConfig.destinationType === 'mine' || dest.encounterName.endsWith(' Asteroid');
                        const isRefiner = dest.destinationType === 'refiner';
                        const isHerald = dest.encounterName === 'The Herald';
                        const isMapmaker = dest.encounterName === 'The Mapmaker';
                        const prefix = isMine ? '[MINE]' : isRefiner ? '[REFINER]' : isHerald ? '[BEACON]' : isMapmaker ? '[MAPS]' : '[VENDOR]';
                        opt.textContent = `${prefix} ${dest.encounterName.replace(/^\[COMMON\] /, '')}`;
                        select.appendChild(opt);
                    }
                }
            }

            // Restore selection if still valid
            if (current && select.querySelector(`option[value="${current}"]`)) {
                select.value = current;
            } else if (select.options.length > 0) {
                select.value = select.options[0].value;
                currentDestination = select.options[0].value;
            }

            // Hide dropdown if no options, no config, or no destinations defined
            if (!zoneConfig || zoneConfig.destinations.length === 0 || select.options.length === 0) {
                select.style.display = 'none';
            } else {
                select.style.display = '';
            }
        }

        function changeDestination(destValue) {
            currentDestination = destValue;

            // Update description based on destination
            const zoneConfig = ZONE_DESTINATIONS[currentLocation];
            if (destValue === 'openworld' && zoneConfig) {
                document.getElementById('location-desc').innerHTML = `<div class="storage-desc-content"><img src="${LOCATIONS[currentLocation].image}" alt="Location"><span>${zoneConfig.openWorldDesc}</span></div>`;
            } else if (destValue !== 'openworld') {
                // At a named destination  show encounter or asteroid description
                const encounters = LOCATIONS[currentLocation].encounters || [];
                const enc = encounters.find(e => e.name === destValue);
                if (enc) {
                    document.getElementById('location-desc').innerHTML = `<div class="storage-desc-content"><img src="${LOCATIONS[currentLocation].image}" alt="Location"><span>${enc.description}</span></div>`;
                } else if (zoneConfig && (zoneConfig.destinationType === 'mine' || destValue.endsWith(' Asteroid'))) {
                    // Mining destination  look up asteroid info
                    const mineralName = destValue.replace(' Asteroid', '');
                    const locationAsteroids = LOCATIONS[currentLocation].mining || [];
                    const asteroid = locationAsteroids.find(a => a.mineral === mineralName);
                    if (asteroid) {
                        document.getElementById('location-desc').innerHTML = `<div class="storage-desc-content"><img src="${LOCATIONS[currentLocation].image}" alt="Location"><span>${mineralName} asteroid. Depth: ${asteroid.depth}ft | Stability: ${asteroid.stability}</span></div>`;
                    }
                }
            }

            // Stop all active timers and battle state
            game.inBattle = false;
            game.currentWave = null;
            game.isAmbush = false;
            game.isBossEncounter = false;
            currentBossEncounter = null;
            currentEncounter = null;
            currentMiningEvent = null;
            shopItems = [];
            if (game.battleInterval) { clearInterval(game.battleInterval); game.battleInterval = null; }
            if (game.regenInterval) { clearInterval(game.regenInterval); game.regenInterval = null; }
            if (game.waveTimer) { clearInterval(game.waveTimer); game.waveTimer = null; }
            if (game.waveExpireTimer) { clearTimeout(game.waveExpireTimer); game.waveExpireTimer = null; }
            clearCountdown();

            // Reset UI
            chatMessages.innerHTML = '';
            storeAvailable = false;
            if (currentPage === 6) showPage(0);
            updatePanelNav();
            setEquipmentLocked(false);
            hideInlineButtons();

            saveGame();

            if (destValue === 'openworld') {
                const name = zoneConfig ? zoneConfig.openWorldName : LOCATION_NAMES[currentLocation];
                addMessage(`[NOW AT ${name}]`, 'system');
            } else {
                addMessage(`[NOW AT ${destValue}]`, 'system');
            }

            // Restart wave cycle
            setTimeout(() => {
                spawnWave();
                startWaveTimer();
            }, 2000);
        }

        function changeLocation(locationKey) {
            const fuelCost = LOCATIONS[locationKey].fuelCost || 0;
            if (game.player.fuel < fuelCost) {
                addMessage(`[NOT ENOUGH FUEL  need ${fuelCost}, have ${game.player.fuel}]`, 'system');
                document.getElementById('location-select').value = currentLocation;
                return;
            }
            if (fuelCost > 0) {
                game.player.fuel -= fuelCost;
                updateStats();
            }
            currentLocation = locationKey;
            currentDestination = 'openworld';

            // Update location image
            document.getElementById('location-image').src = LOCATIONS[locationKey].image;

            // Update description  use open world desc if available
            const zoneConfig = ZONE_DESTINATIONS[locationKey];
            if (zoneConfig) {
                document.getElementById('location-desc').innerHTML = `<div class="storage-desc-content"><img src="${LOCATIONS[locationKey].image}" alt="Location"><span>${zoneConfig.openWorldDesc}</span></div>`;
            } else {
                document.getElementById('location-desc').innerHTML = `<div class="storage-desc-content"><img src="${LOCATIONS[locationKey].image}" alt="Location"><span>${LOCATIONS[locationKey].desc}</span></div>`;
            }
            updateDestinationDropdown();

            // Stop all active timers and battle state
            game.inBattle = false;
            game.currentWave = null;
            game.isAmbush = false;
            game.isBossEncounter = false;
            currentBossEncounter = null;
            currentEncounter = null;
            currentMiningEvent = null;
            shopItems = [];
            if (game.battleInterval) { clearInterval(game.battleInterval); game.battleInterval = null; }
            if (game.regenInterval) { clearInterval(game.regenInterval); game.regenInterval = null; }
            if (game.fuelRegenInterval) { clearInterval(game.fuelRegenInterval); game.fuelRegenInterval = null; }
            if (game.waveTimer) { clearInterval(game.waveTimer); game.waveTimer = null; }
            if (game.waveExpireTimer) { clearTimeout(game.waveExpireTimer); game.waveExpireTimer = null; }
            clearCountdown();

            // Reset UI
            chatMessages.innerHTML = '';
            storeAvailable = false;
            if (currentPage === 6) showPage(0);
            updatePanelNav();
            setEquipmentLocked(false);
            hideInlineButtons();

            saveGame();

            addMessage(`[NOW IN ${LOCATION_NAMES[locationKey]}]`, 'system');
            startFuelRegen();

            // Restart wave cycle
            setTimeout(() => {
                spawnWave();
                startWaveTimer();
            }, 2000);
        }

        document.getElementById('location-select').addEventListener('change', (e) => {
            changeLocation(e.target.value);
        });

        document.getElementById('destination-select').addEventListener('change', (e) => {
            changeDestination(e.target.value);
        });

        // Label map for message types
        const MESSAGE_LABELS = {
            system: 'SYSTEM',
            systemblue: 'SYSTEM',
            enemy: 'ENEMY',
            player: 'MECH',
            battle: 'BATTLE',
            damage: 'DAMAGE',
            victory: 'VICTORY',
            defeat: 'DEFEAT',
            levelup: 'LEVEL UP',
            turncounter: 'TURN'
        };

        function numberToWord(n) {
            const words = ['ZERO','ONE','TWO','THREE','FOUR','FIVE','SIX','SEVEN','EIGHT','NINE','TEN',
                'ELEVEN','TWELVE','THIRTEEN','FOURTEEN','FIFTEEN','SIXTEEN','SEVENTEEN','EIGHTEEN','NINETEEN','TWENTY'];
            return words[n] || String(n);
        }

        // Add message to chat with delay
        async function addMessage(text, type = 'system', options = {}) {
            const img = options.image || (type === 'system' ? 'images/system.gif' : type === 'victory' ? 'images/PLUS.gif' : 'images/IMAGE.gif');
            const label = options.label || MESSAGE_LABELS[type] || type.toUpperCase();

            const msg = document.createElement('div');
            msg.className = `message ${type}`;

            const avatar = document.createElement('div');
            avatar.className = options.characterDialogue ? 'message-avatar character-avatar' : 'message-avatar';
            const avatarImg = document.createElement('img');
            avatarImg.src = img;
            avatarImg.alt = '';
            avatar.appendChild(avatarImg);

            const content = document.createElement('div');
            content.className = 'message-content';

            const labelEl = document.createElement('div');
            labelEl.className = 'message-label';
            labelEl.textContent = label;

            const textEl = document.createElement('div');
            textEl.className = 'message-text';
            textEl.textContent = text;

            content.appendChild(labelEl);
            content.appendChild(textEl);

            if (type !== 'turncounter') {
                msg.appendChild(avatar);
            }
            msg.appendChild(content);

            chatMessages.appendChild(msg);
            msg.scrollIntoView({ behavior: 'smooth', block: 'end' });
            await new Promise(resolve => setTimeout(resolve, 800));
        }

        // Update UI
        function updateStats() {
            const p = game.player;

            // HP Bar
            const hpPercent = (p.hp / p.maxHp) * 100;
            document.getElementById('hp-bar').style.width = `${hpPercent}%`;
            document.getElementById('hp-label').textContent = `HP: ${p.hp} / ${p.maxHp}`;

            // XP Bar
            const xpPercent = (p.xp / p.xpToLevel) * 100;
            document.getElementById('xp-bar').style.width = `${xpPercent}%`;
            document.getElementById('xp-label').textContent = `SILICON: ${p.xp} / ${p.xpToLevel}`;

            // XP Stats
            document.getElementById('stat-xp').textContent = p.xp;
            document.getElementById('stat-reqxp').textContent = p.xpToLevel;

            // Fuel Bar
            const fuelPercent = (p.fuel / p.maxFuel) * 100;
            document.getElementById('fuel-bar').style.width = `${fuelPercent}%`;
            document.getElementById('fuel-label').textContent = `FUEL: ${p.fuel} / ${p.maxFuel}`;

            // Stats
            document.getElementById('stat-level').textContent = p.level;
            document.getElementById('stat-attack').textContent = p.attack;
            document.getElementById('stat-speed').textContent = p.speed;
            document.getElementById('stat-defence').textContent = p.defence;
            document.getElementById('stat-breaker').textContent = `${p.breaker}%`;
            document.getElementById('stat-mining').textContent = p.mining;
            document.getElementById('stat-regen').textContent = p.regen;

            // Enable/disable upgrade buttons based on XP
            const canUpgrade = p.xp >= p.xpToLevel;
            document.querySelectorAll('.stat-upgrade').forEach(btn => {
                btn.disabled = !canUpgrade;
            });
        }

        // Recalculate stats from base + equipment
        function recalculateStats() {
            const p = game.player;
            const oldMaxHp = p.maxHp;

            // Start with base stats
            p.maxHp = p.baseMaxHp;
            p.attack = p.baseAttack;
            p.speed = p.baseSpeed;
            p.defence = p.baseDefence;
            p.breaker = p.baseBreaker;
            p.mining = p.baseMining;
            p.regen = p.baseRegen;

            // Add equipment bonuses
            for (const slot in game.equipment) {
                const itemName = game.equipment[slot];
                if (itemName) {
                    const item = ITEMS.find(i => i.name === itemName) || FORGER_ITEMS.find(i => i.name === itemName);
                    if (item && item.stats) {
                        if (item.stats.hp) p.maxHp += item.stats.hp;
                        if (item.stats.attack) p.attack += item.stats.attack;
                        if (item.stats.speed) p.speed += item.stats.speed;
                        if (item.stats.defence) p.defence += item.stats.defence;
                        if (item.stats.breaker) p.breaker += item.stats.breaker;
                        if (item.stats.mining) p.mining += item.stats.mining;
                        if (item.stats.regen) p.regen += item.stats.regen;
                    }
                }
            }

            // Adjust current HP if it exceeds new max
            if (p.hp > p.maxHp) {
                p.hp = p.maxHp;
            }

            updateStats();
        }

        // Get current XP bonus from equipped processor
        function getXpBonus() {
            const processorName = game.equipment.processor;
            if (!processorName) return 0;
            const item = ITEMS.find(i => i.name === processorName);
            if (item && item.stats && item.stats.xpBonus) return item.stats.xpBonus;
            return 0;
        }

        // Update equipment dropdowns with inventory items
        const SLOT_LABELS = {
            body: 'BODY', legs: 'LEGS', arms: 'ARMS', weapon: 'WEAPON',
            chip: 'CHIP', processor: 'PROC', implant: 'IMPLANT', pilot: 'PILOT', drill: 'DRILL', mindsync: 'MINDSYNC'
        };

        function updateEquipmentUI() {
            const slots = ['body', 'legs', 'arms', 'weapon', 'chip', 'processor', 'pilot', 'drill', 'implant', 'mindsync'];

            slots.forEach(slot => {
                const select = document.getElementById(`equip-${slot}`);
                const currentValue = game.equipment[slot] || '';
                const tag = SLOT_LABELS[slot];

                // Clear and rebuild options
                const slotItems = game.inventory.filter(item => item.type === slot);
                select.innerHTML = `<option value="">[${tag}] ${slotItems.length} items</option>`;

                // Add items from inventory that match this slot
                slotItems.forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.name;
                    option.textContent = `[${tag}] ${item.name}`;
                    if (item.name === currentValue) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
            });
            updateEquipmentDescs();
        }

        // Update equipment description text under each dropdown
        function updateEquipmentDescs() {
            const slots = ['body', 'legs', 'arms', 'weapon', 'chip', 'processor', 'pilot', 'drill', 'implant', 'mindsync'];
            slots.forEach(slot => {
                const descEl = document.getElementById(`equip-desc-${slot}`);
                const itemName = game.equipment[slot];
                if (itemName) {
                    const item = ITEMS.find(i => i.name === itemName) || FORGER_ITEMS.find(i => i.name === itemName);
                    if (item && item.desc) {
                        const img = item.image ? `<img src="${item.image}" alt="${item.name}">` : '';
                        descEl.innerHTML = `<div class="storage-desc-content">${img}<span>${item.desc}</span></div>`;
                        descEl.classList.add('visible');
                    } else {
                        descEl.innerHTML = '';
                        descEl.classList.remove('visible');
                    }
                } else {
                    descEl.innerHTML = '';
                    descEl.classList.remove('visible');
                }
            });
        }

        // Handle equipment change
        function onEquipmentChange(slot, itemName) {
            if (game.inBattle) return; // Can't change during battle

            game.equipment[slot] = itemName || null;
            recalculateStats();
            updateEquipmentDescs();
            startRegen();
            saveGame();
        }

        // Lock/unlock equipment dropdowns
        function setEquipmentLocked(locked) {
            const slots = ['body', 'legs', 'arms', 'weapon', 'chip', 'processor', 'pilot', 'drill', 'implant', 'mindsync'];
            slots.forEach(slot => {
                document.getElementById(`equip-${slot}`).disabled = locked;
            });
            document.getElementById('location-select').disabled = locked;
            document.getElementById('destination-select').disabled = locked;
        }

        // Add item to inventory
        function addItemToInventory(item) {
            game.inventory.push(item);
            updateEquipmentUI();
            saveGame();
        }

        // Get random item drop from defeated enemy
        function getRandomItemDrop(enemyName) {
            // Filter items that can drop in this zone from this enemy
            const droppableItems = ITEMS.filter(item => {
                if (!item.dropRate || item.dropRate <= 0) return false;
                if (item.zone && item.zone !== currentLocation) return false;
                if (item.droppedBy && item.droppedBy.length > 0 && !item.droppedBy.includes(enemyName)) return false;
                return true;
            });

            if (droppableItems.length === 0) return null;

            // Calculate total drop rate
            const totalRate = droppableItems.reduce((sum, item) => sum + item.dropRate, 0);

            // Random selection
            let roll = Math.random() * totalRate;
            for (const item of droppableItems) {
                roll -= item.dropRate;
                if (roll <= 0) {
                    return item;
                }
            }

            return droppableItems[0];
        }

        // Level up check (no-op, kept for compatibility)
        function checkLevelUp() {}

        // Manual stat upgrade: spend Silicon to increase a stat by 1 and level up
        function upgradeStat(stat) {
            const p = game.player;
            if (p.xp < p.xpToLevel) return;

            const baseMap = {
                attack: 'baseAttack',
                speed: 'baseSpeed',
                defence: 'baseDefence',
                breaker: 'baseBreaker',
                mining: 'baseMining',
                regen: 'baseRegen'
            };

            const baseKey = baseMap[stat];
            if (!baseKey) return;

            p.xp -= p.xpToLevel;
            p.level++;
            p.xpToLevel = 10 * p.level * p.level;
            p[baseKey] += 1;
            p.baseMaxHp += 1;

            recalculateStats();
            startRegen();
            updateStats();
            saveGame();

            addMessage(`[LEVEL ${p.level}] ${stat.toUpperCase()} +1 | MAX HP +1`, 'system');
        }

        // Select enemy type based on player level and appearance rates
        function selectEnemyType() {
            const playerLevel = game.player.level;

            // Filter enemies by level requirement
            const available = getEnemies().filter(e => e.minLevel <= playerLevel);

            // Calculate total appearance rate
            const totalRate = available.reduce((sum, e) => sum + e.appearanceRate, 0);

            // Random selection weighted by appearance rate
            let roll = Math.random() * totalRate;
            for (const enemy of available) {
                roll -= enemy.appearanceRate;
                if (roll <= 0) {
                    return enemy;
                }
            }

            // Fallback to first available
            return available[0];
        }

        // Generate enemy wave
        function generateWave() {
            const enemyType = selectEnemyType();
            const min = enemyType.squadMin || 1;
            const max = enemyType.squadMax || 1;
            const enemyCount = Math.floor(Math.random() * (max - min + 1)) + min;

            return {
                enemyType: enemyType,
                count: enemyCount,
                remaining: enemyCount,
                currentTarget: 1, // Which enemy we're fighting (1-indexed)
                currentEnemy: null, // Will hold current enemy's HP in battle
                turn: 0
            };
        }

        // Select encounter type based on player level and appearance rates
        function selectEncounterType() {
            const playerLevel = game.player.level;

            // Filter encounters by level requirement
            const available = getEncounters().filter(e => e.minLevel <= playerLevel);
            if (available.length === 0) return null;

            // Calculate total appearance rate
            const totalRate = available.reduce((sum, e) => sum + e.appearanceRate, 0);

            // Random selection weighted by appearance rate
            let roll = Math.random() * totalRate;
            for (const encounter of available) {
                roll -= encounter.appearanceRate;
                if (roll <= 0) {
                    return encounter;
                }
            }

            return available[0];
        }

        // Find item by name in ITEMS or STORY_ITEMS
        function findShopItem(name) {
            return ITEMS.find(i => i.name === name) || STORY_ITEMS.find(i => i.name === name) || REFINED_MINERALS.find(i => i.name === name) || FORGER_ITEMS.find(i => i.name === name) || null;
        }

        // Generate shop items based on encounter slot configuration
        function generateShopItems(encounter) {
            const items = [];
            const slots = [encounter.itemSlot1, encounter.itemSlot2, encounter.itemSlot3, encounter.itemSlot4];
            const usedItems = new Set(); // Track used items to avoid duplicates

            for (let i = 0; i < slots.length; i++) {
                if (slots[i] === null || slots[i] === undefined) { items.push(null); continue; }
                const slotConfig = slots[i];
                let item = null;

                if (slotConfig.length > 0) {
                    // Pick randomly from the configured item names, skip already-owned story items
                    const availableInSlot = slotConfig.filter(name => {
                        if (usedItems.has(name)) return false;
                        const si = STORY_ITEMS.find(s => s.name === name);
                        if (si && (game.storyItems || []).includes(name)) return false;
                        // Check requires  item only available if player has all prerequisite items
                        if (si && si.requires && !si.requires.every(req => (game.storyItems || []).includes(req))) return false;
                        return true;
                    });
                    if (availableInSlot.length > 0) {
                        const itemName = availableInSlot[Math.floor(Math.random() * availableInSlot.length)];
                        item = findShopItem(itemName);
                    }
                } else {
                    // Empty array = pick random from zone-appropriate equipment items
                    const availableItems = ITEMS.filter(i => !usedItems.has(i.name) && (!i.zone || i.zone === currentLocation));
                    if (availableItems.length > 0) {
                        item = availableItems[Math.floor(Math.random() * availableItems.length)];
                    }
                }

                if (item) {
                    usedItems.add(item.name);
                    items.push(item);
                } else {
                    items.push(null);
                }
            }

            return items;
        }

        // Update shop UI with current items
        function updateShopUI() {
            const playerXP = game.player.xp;

            for (let i = 0; i < 4; i++) {
                const wrapper = document.getElementById(`shop-wrapper-${i + 1}`);
                const nameEl = document.getElementById(`shop-name-${i + 1}`);
                const descEl = document.getElementById(`shop-desc-${i + 1}`);
                const buyBtn = document.getElementById(`shop-buy-${i + 1}`);
                const item = shopItems[i];

                if (item) {
                    let tag;
                    if (item.refinedMineral) {
                        tag = 'MINERAL';
                    } else if (item.type) {
                        tag = SLOT_LABELS[item.type] || item.type.toUpperCase();
                    } else if (item.category) {
                        tag = item.category.toUpperCase();
                    } else {
                        tag = 'ITEM';
                    }
                    nameEl.textContent = `[${tag}] ${item.name}`;
                    const img = item.image ? `<img src="${item.image}" alt="${item.name}">` : '';
                    descEl.innerHTML = item.desc ? `<div class="storage-desc-content">${img}<span>${item.desc}</span></div>` : '';

                    if (item.isDecrypterItem) {
                        nameEl.classList.remove('cant-afford');
                        buyBtn.textContent = `[Decrypt: ${item.decrypterKey}]`;
                        buyBtn.disabled = false;
                    } else if (item.forgerPlaceholder) {
                        nameEl.classList.add('cant-afford');
                        buyBtn.textContent = `[No Blueprint]`;
                        buyBtn.disabled = true;
                    } else if (item.mineralCost) {
                        const { mineral, category, count } = item.mineralCost;
                        const has = getMineralCount(mineral, category);
                        const hasScrap = item.scrapCost ? (game.scrap || 0) >= item.scrapCost : true;
                        const canAfford = has >= count && hasScrap;
                        nameEl.classList.toggle('cant-afford', !canAfford);
                        const verb = item.isForgerPreview ? 'Forge' : 'Buy';
                        buyBtn.textContent = item.scrapCost
                            ? `[${verb} ${count} ${mineral} + ${item.scrapCost} Scrap]`
                            : `[${verb} ${count} ${mineral}]`;
                        buyBtn.disabled = !canAfford;
                    } else if (item.scrapCost) {
                        const canAfford = (game.scrap || 0) >= item.scrapCost;
                        nameEl.classList.toggle('cant-afford', !canAfford);
                        buyBtn.textContent = `[Cost: ${item.scrapCost} Scrap]`;
                        buyBtn.disabled = !canAfford;
                    } else {
                        const canAfford = playerXP >= item.cost;
                        nameEl.classList.toggle('cant-afford', !canAfford);
                        buyBtn.textContent = `[Cost: ${item.cost} Silicon]`;
                        buyBtn.disabled = !canAfford;
                    }
                    wrapper.classList.add('visible');
                } else {
                    wrapper.classList.remove('visible');
                }
            }
        }

        // Get the installation types for a given mineral name
        function getForgerSlotsForMineral(mineralName) {
            for (const tier of FORGER_TIERS) {
                const pos = tier.minerals.indexOf(mineralName);
                if (pos !== -1) {
                    return { tier: tier.tier, zone: tier.zone, types: FORGER_SLOT_GROUPS[pos] };
                }
            }
            return null;
        }

        // Build a preview item for the forge shop (stats hidden until purchase)
        function getForgerItem(mineralName, slotType) {
            return generateForgerPreview(mineralName, slotType);
        }

        // Populate the forge mineral dropdown with all minerals grouped by tier
        function updateForgeDropdown() {
            const select = document.getElementById('forge-mineral-select');
            select.innerHTML = '<option value="">[SELECT MINERAL]</option>';

            for (const tier of FORGER_TIERS) {
                const group = document.createElement('optgroup');
                group.label = `Tier ${tier.tier}  ${tier.zone}`;

                for (const mineral of tier.minerals) {
                    const refinedCount = getMineralCount("Refined " + mineral, "refined");
                    const option = document.createElement('option');
                    option.value = mineral;
                    option.textContent = `${mineral} (${refinedCount} refined)`;
                    group.appendChild(option);
                }

                select.appendChild(group);
            }
        }

        // Handle forge mineral dropdown selection
        function onForgeMineralChange() {
            const select = document.getElementById('forge-mineral-select');
            const mineralName = select.value;

            if (!mineralName) {
                shopItems = [null, null, null, null];
                updateShopUI();
                return;
            }

            const info = getForgerSlotsForMineral(mineralName);
            if (!info) {
                shopItems = [null, null, null, null];
                updateShopUI();
                return;
            }

            // Populate shop slots with items for this mineral's 3 installation types
            shopItems = info.types.map(type => {
                const item = getForgerItem(mineralName, type);
                if (item) return item;
                // Placeholder for slots with no blueprint yet
                const tag = SLOT_LABELS[type] || type.toUpperCase();
                return {
                    name: "-- No Blueprint --",
                    type: type,
                    desc: "No blueprint available yet. Check back later.",
                    forgerPlaceholder: true
                };
            });
            updateShopUI();
        }

        // ========== SALVAGE YARD FUNCTIONS ==========

        // Calculate scrap value for an item
        function getSalvageValue(item) {
            if (item.isForged) {
                // Forged items: tier * 5 scrap
                return (item.forgerTier || 1) * 5;
            }
            // Regular items: based on XP cost
            return Math.max(1, Math.ceil((item.cost || 5) / 5));
        }

        // Build stat summary string for an item
        function getSalvageStatSummary(item) {
            if (!item.stats) return '';
            const parts = [];
            if (item.stats.hp) parts.push(`+${item.stats.hp} HP`);
            if (item.stats.attack) parts.push(`+${item.stats.attack} ATK`);
            if (item.stats.defence) parts.push(`+${item.stats.defence} DEF`);
            if (item.stats.speed) parts.push(`+${item.stats.speed} SPD`);
            if (item.stats.breaker) parts.push(`+${item.stats.breaker} BREAKER`);
            if (item.stats.mining) parts.push(`+${item.stats.mining} MINING`);
            if (item.stats.regen) parts.push(`+${item.stats.regen} REGEN`);
            if (item.stats.xpBonus) parts.push(`+${item.stats.xpBonus} SILICON`);
            return parts.join(' | ');
        }

        // Build set of inventory indices that are currently equipped
        function getEquippedIndices() {
            const indices = new Set();
            for (const slot in game.equipment) {
                const equippedName = game.equipment[slot];
                if (!equippedName) continue;
                // Find the first inventory item with this name that isn't already claimed
                const idx = game.inventory.findIndex((item, i) => item.name === equippedName && !indices.has(i));
                if (idx !== -1) indices.add(idx);
            }
            return indices;
        }

        // Populate the salvage dropdown with unequipped installations
        function updateSalvageDropdown() {
            const select = document.getElementById('salvage-item-select');
            const preview = document.getElementById('salvage-preview');
            const sellBtn = document.getElementById('salvage-sell-btn');

            select.innerHTML = '<option value="">[SELECT INSTALLATION TO SELL]</option>';

            const equippedIndices = getEquippedIndices();
            const slots = ['body', 'legs', 'arms', 'weapon', 'chip', 'processor', 'pilot', 'drill', 'implant', 'mindsync'];

            let totalSellable = 0;

            slots.forEach(slot => {
                const tag = SLOT_LABELS[slot] || slot.toUpperCase();
                const group = document.createElement('optgroup');
                group.label = tag;
                let groupCount = 0;

                game.inventory.forEach((item, invIndex) => {
                    if (item.type !== slot) return;
                    if (equippedIndices.has(invIndex)) return;

                    const option = document.createElement('option');
                    option.value = invIndex;
                    const scrapValue = getSalvageValue(item);
                    option.textContent = `${item.name} (${scrapValue} scrap)`;
                    group.appendChild(option);
                    groupCount++;
                });

                if (groupCount > 0) {
                    select.appendChild(group);
                    totalSellable += groupCount;
                }
            });

            if (totalSellable === 0) {
                select.innerHTML = '<option value="">[NO INSTALLATIONS TO SELL]</option>';
            }

            // Reset preview and button
            preview.classList.remove('visible');
            preview.innerHTML = '';
            sellBtn.disabled = true;
            sellBtn.textContent = '--';

            // Update sell-all button
            const sellAllBtn = document.getElementById('salvage-sell-all-btn');
            if (totalSellable > 1) {
                const equippedIdx = getEquippedIndices();
                let totalScrap = 0;
                game.inventory.forEach((item, i) => {
                    if (!equippedIdx.has(i)) totalScrap += getSalvageValue(item);
                });
                sellAllBtn.textContent = `[Sell All Unequipped (${totalSellable}) for ${totalScrap} Scrap]`;
                sellAllBtn.style.display = 'block';
            } else {
                sellAllBtn.style.display = 'none';
            }
        }

        // Handle salvage dropdown selection
        function onSalvageItemChange() {
            const select = document.getElementById('salvage-item-select');
            const preview = document.getElementById('salvage-preview');
            const sellBtn = document.getElementById('salvage-sell-btn');
            const invIndex = parseInt(select.value);

            if (isNaN(invIndex) || !game.inventory[invIndex]) {
                preview.classList.remove('visible');
                sellBtn.disabled = true;
                sellBtn.textContent = '--';
                return;
            }

            const item = game.inventory[invIndex];
            const scrapValue = getSalvageValue(item);
            const tag = SLOT_LABELS[item.type] || item.type.toUpperCase();
            const statLine = getSalvageStatSummary(item);

            preview.innerHTML = `<div class="salvage-item-name">[${tag}] ${item.name}</div>`
                + (item.desc ? `<div>${item.desc}</div>` : '')
                + (statLine ? `<div class="salvage-item-stats">${statLine}</div>` : '');
            preview.classList.add('visible');

            sellBtn.textContent = `[Sell for ${scrapValue} Scrap]`;
            sellBtn.disabled = false;
        }

        // Sell the selected installation
        function sellSalvageItem() {
            const sellBtn = document.getElementById('salvage-sell-btn');
            if (sellBtn.disabled) return;

            const select = document.getElementById('salvage-item-select');
            const invIndex = parseInt(select.value);

            if (isNaN(invIndex) || !game.inventory[invIndex]) return;

            // Disable button immediately to prevent double-click
            sellBtn.disabled = true;

            const item = game.inventory[invIndex];
            const scrapValue = getSalvageValue(item);

            // Remove from inventory
            game.inventory.splice(invIndex, 1);

            // Add scrap
            game.scrap = (game.scrap || 0) + scrapValue;

            addMessage(`Sold: ${item.name} for ${scrapValue} Scrap`, 'victory');
            addMessage(`Total scrap: ${game.scrap}`, 'system');

            recalculateStats();
            updateEquipmentUI();
            updateStats();
            updateStorageUI();
            saveGame();

            // Refresh the salvage dropdown
            updateSalvageDropdown();
        }

        // Sell all unequipped installations
        function sellAllSalvageItems() {
            const equippedIndices = getEquippedIndices();
            let totalScrap = 0;
            let count = 0;

            // Collect unequipped items (iterate in reverse to safely splice)
            for (let i = game.inventory.length - 1; i >= 0; i--) {
                if (equippedIndices.has(i)) continue;
                const item = game.inventory[i];
                totalScrap += getSalvageValue(item);
                game.inventory.splice(i, 1);
                count++;
            }

            if (count === 0) return;

            game.scrap = (game.scrap || 0) + totalScrap;

            addMessage(`Sold ${count} installation${count > 1 ? 's' : ''} for ${totalScrap} Scrap`, 'victory');
            addMessage(`Total scrap: ${game.scrap}`, 'system');

            recalculateStats();
            updateEquipmentUI();
            updateStats();
            updateStorageUI();
            saveGame();

            updateSalvageDropdown();
        }

        // Decrypter: key-to-powerup mapping
        // Each sealed key decrypts into a breaker key (pilot soul released, power unlocked)
        const DECRYPTER_POWERUPS = {
            "Unknown Sealed Key": {
                name: "Your Combobreaker Key",
                desc: "Your own soul, decrypted. The Mapmaker planted it in you before the end, and now you know why you're awake. Combobreaker  chance to deal double damage. The game is named after you.",
                category: "powerup",
                image: "images/IMAGE.gif"
            },
            "Rusted KV-8 Grinder's Sealed Key": {
                name: "Chunk's Steelbreaker Key",
                desc: "Riley 'Chunk' Kowalski. Scrap Refiner. Steelbreaker  chance to gain double scrap. Chunk's salvage instinct, hardwired into your systems.",
                category: "powerup",
                image: "images/IMAGE.gif"
            },
            "Shelled MK-IV Bulwark's Sealed Key": {
                name: "Sarge's Shieldbreaker Key",
                desc: "Marcus 'Sarge' Oduya. Squad Defender. Shieldbreaker  chance to double defence at the start of a round. Sarge's wall goes up.",
                category: "powerup",
                image: "images/IMAGE.gif"
            },
            "Shadowed S-12 Wraith's Sealed Key": {
                name: "Ghost's Visionbreaker Key",
                desc: "Yuki 'Ghost' Tanaka. Infiltrator. Visionbreaker  chance to disappear and completely avoid an attack. Ghost's vanishing act.",
                category: "powerup",
                image: "images/IMAGE.gif"
            },
            "Depressurized DR-7 Prospector's Sealed Key": {
                name: "Bolt's Stonebreaker Key",
                desc: "Petra 'Bolt' Lindgren. Miner. Stonebreaker  chance to add mining stat to asteroid stability. Bolt reinforcing the rock.",
                category: "powerup",
                image: "images/IMAGE.gif"
            },
            "Irradiated AX-3 Ravager's Sealed Key": {
                name: "Fang's Strikebreaker Key",
                desc: "Diego 'Fang' Reyes. Assault. Strikebreaker  chance to ignore enemy defence stat entirely. Fang hits like the armour isn't there.",
                category: "powerup",
                image: "images/IMAGE.gif"
            },
            "Corroded SC-1 Flicker's Sealed Key": {
                name: "Wire's Speedbreaker Key",
                desc: "Jess 'Wire' Nakamura. Scout. Speedbreaker  chance to attack twice. She saved the Mapmaker. She saved you. She became the Herald.",
                category: "powerup",
                image: "images/IMAGE.gif"
            },
            "Slag-Coated HG-6 Devastator's Sealed Key": {
                name: "Anvil's Crushbreaker Key",
                desc: "Dmitri 'Anvil' Volkov. Heavy Gunner. Crushbreaker  chance for damage to hit the entire enemy group. One swing, everything feels it.",
                category: "powerup",
                image: "images/IMAGE.gif"
            },
            "Frozen MD-5 Lifeline's Sealed Key": {
                name: "Frost's Painbreaker Key",
                desc: "Elise 'Frost' Calloway. Medic. Painbreaker  chance to regain HP equal to regen stat. Frost patching you up between blows.",
                category: "powerup",
                image: "images/IMAGE.gif"
            },
            "Gilded EN-9 Tinker's Sealed Key": {
                name: "Ace's Powerbreaker Key",
                desc: "Tariq 'Ace' Hassan. Mechanic. Powerbreaker  chance to double silicon gain. Ace squeezing more out of every wreck.",
                category: "powerup",
                image: "images/IMAGE.gif"
            },
            "Blighted EW-0 Phantom's Sealed Key": {
                name: "Null's Soulbreaker Key",
                desc: "Zara 'Null' Okonkwo. Specialist. Soulbreaker  chance to trigger a parry attack when hit. You get hit, you hit back.",
                category: "powerup",
                image: "images/IMAGE.gif"
            },
            "Scorched CM-1 Sovereign's Sealed Key": {
                name: "Rex's Warbreaker Key",
                desc: "Kane 'Rex' Hargrove. Commander. Warbreaker  chance for Combobreaker and Speedbreaker to escalate to 4X. Rex amplifying the squad.",
                category: "powerup",
                image: "images/IMAGE.gif"
            },
            "Mapmaker's Sealed Key": {
                name: "Mapmaker's Skybreaker Key",
                desc: "Oren 'Mapmaker' Vasquez. Navigator. Skybreaker  doubles all breaker proc chances. The Mapmaker's final gift.",
                category: "powerup",
                image: "images/IMAGE.gif"
            }
        };

        // Update decrypter key dropdown with collected boss keys
        function updateDecrypterDropdown() {
            const select = document.getElementById('decrypter-key-select');
            select.innerHTML = '<option value="">[SELECT KEY TO DECRYPT]</option>';

            const keyNames = Object.keys(DECRYPTER_POWERUPS);
            const items = game.storyItems || [];

            for (const keyName of keyNames) {
                // Only show keys the player has and hasn't already decrypted
                if (!items.includes(keyName)) continue;
                const powerup = DECRYPTER_POWERUPS[keyName];
                if (items.includes(powerup.name)) continue; // Already decrypted

                const option = document.createElement('option');
                option.value = keyName;
                option.textContent = keyName;
                select.appendChild(option);
            }
        }

        // Handle decrypter key dropdown selection
        function onDecrypterKeyChange() {
            const select = document.getElementById('decrypter-key-select');
            const keyName = select.value;

            if (!keyName) {
                shopItems = [null, null, null, null];
                updateShopUI();
                return;
            }

            const powerup = DECRYPTER_POWERUPS[keyName];
            if (!powerup) {
                shopItems = [null, null, null, null];
                updateShopUI();
                return;
            }

            // Show the powerup in shop slot 1 with the key as the cost
            shopItems = [{
                name: powerup.name,
                desc: powerup.desc,
                category: powerup.category,
                image: powerup.image,
                cost: 0,
                isDecrypterItem: true,
                decrypterKey: keyName
            }, null, null, null];

            updateShopUI();
        }

        // Show shop panel (switch to store page)
        function showShopPanel() {
            storeAvailable = true;

            // Show forge dropdown if this is the forge encounter
            const forgeSelector = document.getElementById('forge-selector');
            const salvageSelector = document.getElementById('salvage-selector');
            const decrypterSelector = document.getElementById('decrypter-selector');
            if (currentEncounter && currentEncounter.isForge) {
                updateForgeDropdown();
                forgeSelector.style.display = 'block';
                salvageSelector.style.display = 'none';
                decrypterSelector.style.display = 'none';
            } else if (currentEncounter && currentEncounter.isSalvageYard) {
                updateSalvageDropdown();
                salvageSelector.style.display = 'block';
                forgeSelector.style.display = 'none';
                decrypterSelector.style.display = 'none';
            } else if (currentEncounter && currentEncounter.isDecrypter) {
                updateDecrypterDropdown();
                decrypterSelector.style.display = 'block';
                forgeSelector.style.display = 'none';
                salvageSelector.style.display = 'none';
            } else {
                forgeSelector.style.display = 'none';
                salvageSelector.style.display = 'none';
                decrypterSelector.style.display = 'none';
            }

            updateShopUI();
            showPage(6);
        }

        // Hide shop panel (leave store page)
        function hideShopPanel() {
            storeAvailable = false;
            const forgeSelect = document.getElementById('forge-mineral-select');
            forgeSelect.value = '';
            document.getElementById('forge-selector').style.display = 'none';
            document.getElementById('salvage-selector').style.display = 'none';
            document.getElementById('decrypter-selector').style.display = 'none';
            document.getElementById('decrypter-key-select').value = '';
            document.getElementById('salvage-item-select').value = '';
            document.getElementById('salvage-preview').classList.remove('visible');
            document.getElementById('salvage-sell-btn').disabled = true;
            document.getElementById('salvage-sell-all-btn').style.display = 'none';
            if (currentPage === 6) showPage(0);
            updatePanelNav();
        }

        // Handle shop purchase
        function purchaseItem(index) {
            const item = shopItems[index];
            if (!item || item.forgerPlaceholder) return;

            if (item.isDecrypterItem) {
                // Decrypter: consume the key, grant the powerup
                const keyName = item.decrypterKey;
                const keyIndex = (game.storyItems || []).indexOf(keyName);
                if (keyIndex === -1) return; // Key not found

                game.storyItems.splice(keyIndex, 1);
                addStoryItem(item.name);
                addMessage(`[DECRYPTED] ${keyName} consumed.`, 'system');
                addMessage(`Received: ${item.name}`, 'victory');
                addMessage(`"${DECRYPTER_POWERUPS[keyName].desc}"`, 'system');
                updateStats();
                updateMiningUI();
                shopItems[index] = null;
                updateShopUI();
                updateDecrypterDropdown();
                document.getElementById('decrypter-key-select').value = '';
                saveGame();
                return;
            }

            if (item.mineralCost) {
                // Mineral cost purchase
                const { mineral, category, count } = item.mineralCost;
                if (getMineralCount(mineral, category) < count) return;
                if (item.scrapCost && (game.scrap || 0) < item.scrapCost) return;
                removeMinerals(mineral, category, count);
                if (item.scrapCost) game.scrap -= item.scrapCost;

                if (item.isForgerPreview) {
                    // Blind forge: generate the real item now, reveal stats
                    const forged = generateForgerItem(item.forgerMineral, item.forgerSlot);
                    registerForgedItem(forged);
                    addItemToInventory(forged);
                    const scrapMsg = item.scrapCost ? ` + ${item.scrapCost} Scrap` : '';
                    addMessage(`Forged: ${item.name} for ${count} ${mineral}${scrapMsg}`, 'system');
                    addMessage(`Received: ${forged.name}`, 'victory');
                } else if (item.refinedMineral) {
                    addMineral(item.name, 'refined');
                } else if (item.category) {
                    addStoryItem(item.name);
                } else {
                    if (item.isForged) registerForgedItem(item);
                    addItemToInventory(item);
                }
                if (!item.isForgerPreview) {
                    const scrapMsg = item.scrapCost ? ` + ${item.scrapCost} Scrap` : '';
                    addMessage(`Purchased: ${item.name} for ${count} ${mineral}${scrapMsg}`, 'victory');
                }
            } else if (item.scrapCost) {
                // Scrap cost purchase (e.g. XP service)
                if ((game.scrap || 0) < item.scrapCost) return;
                game.scrap -= item.scrapCost;
                if (item.xpReward) {
                    game.player.xp += item.xpReward;
                    addMessage(`Purchased: ${item.name} for ${item.scrapCost} Scrap  gained ${item.xpReward} Silicon`, 'victory');
                } else {
                    addItemToInventory(item);
                    addMessage(`Purchased: ${item.name} for ${item.scrapCost} Scrap`, 'victory');
                }
            } else {
                // XP cost purchase
                if (game.player.xp < item.cost) return;
                game.player.xp -= item.cost;
                if (item.category) {
                    addStoryItem(item.name);
                } else {
                    addItemToInventory(item);
                }
                addMessage(`Purchased: ${item.name} for ${item.cost} Silicon`, 'victory');
            }
            updateStats();
            updateMiningUI();

            // Forge: refresh the view (mineral counts changed), keep slots visible
            if (currentEncounter && currentEncounter.isForge) {
                updateForgeDropdown();
                onForgeMineralChange();
            } else if (item.xpReward || item.refinedMineral) {
                // Repeatable: services and mineral refining stay in slot
                updateShopUI();
            } else {
                // Regular shop: remove item from slot
                shopItems[index] = null;
                updateShopUI();
            }
        }

        // End shop encounter
        function endShopEncounter() {
            hideShopPanel();
            // Remove dialogue buttons
            const dialogueContainer = document.querySelector('.dialogue-btn-container');
            if (dialogueContainer) dialogueContainer.remove();
            if (game.shopLeaveBtn && game.shopLeaveBtn.parentNode) {
                game.shopLeaveBtn.remove();
                game.shopLeaveBtn = null;
            }
            currentEncounter = null;
            shopItems = [];
            addMessage(`Transaction complete. The trader departs.`, 'system');
            startWaveTimer();
        }

        // Spawn encounter
        function spawnEncounter() {
            const encounter = selectEncounterType();
            if (!encounter) return false;

            currentEncounter = encounter;

            // Forge, Salvage Yard, and Decrypter use custom UI, not pre-generated items
            if (encounter.isForge || encounter.isSalvageYard || encounter.isDecrypter) {
                shopItems = [null, null, null, null];
            } else {
                shopItems = generateShopItems(encounter);
            }

            addMessage(`[ENCOUNTER] ${encounter.name}`, 'system');
            const isVendorDest = currentDestination && currentDestination !== 'openworld';
            addMessage(isVendorDest && encounter.discoveredDescription ? encounter.discoveredDescription : encounter.description, 'system', { label: encounter.name });

            // At a vendor destination or auto-engage encounter, skip countdown and buttons
            if (isVendorDest || encounter.autoEngage) {
                engageEncounter();
                return true;
            }

            // Create countdown message
            let secondsLeft = Math.floor(game.WAVE_EXPIRE / 1000);
            const countdownMsg = document.createElement('div');
            countdownMsg.className = 'message system';
            countdownMsg.textContent = `Signal available for [${secondsLeft}] seconds.`;
            chatMessages.appendChild(countdownMsg);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            game.countdownMsg = countdownMsg;

            // Update countdown every second
            game.countdownInterval = setInterval(() => {
                secondsLeft--;
                if (secondsLeft > 0) {
                    countdownMsg.textContent = `Signal available for [${secondsLeft}] seconds.`;
                } else {
                    clearCountdown();
                }
            }, 1000);

            showInlineButtons();

            // Set expiration timer
            if (game.waveExpireTimer) clearTimeout(game.waveExpireTimer);
            game.waveExpireTimer = setTimeout(() => {
                clearCountdown();
                if (currentEncounter) {
                    addMessage(`Signal lost. The ${encounter.name} has moved on.`, 'system');
                    currentEncounter = null;
                    shopItems = [];
                    hideInlineButtons();
                    startWaveTimer();
                }
            }, game.WAVE_EXPIRE);

            return true;
        }

        // Engage encounter (shop)
        async function engageEncounter() {
            if (!currentEncounter) return;

            // Clear expire timer and countdown
            if (game.waveExpireTimer) {
                clearTimeout(game.waveExpireTimer);
                game.waveExpireTimer = null;
            }
            clearCountdown();

            const useDiscoveredEngage = currentDestination && currentDestination !== 'openworld' && currentEncounter.discoveredEngageText;
            await addMessage(useDiscoveredEngage ? currentEncounter.discoveredEngageText : currentEncounter.engageText, 'system', { label: currentEncounter.name, image: currentEncounter.characterImage, characterDialogue: !!currentEncounter.characterImage });

            // The Professor gives the Ratpile map for free if the player doesn't have it
            if (currentEncounter.name === 'The Professor' && !(game.storyItems || []).includes('Map: The Ratpile')) {
                addStoryItem('Map: The Ratpile');
                await addMessage(`"Here  take this. It's a map to The Ratpile. Not much down there but rats, but it's a start."`, 'system', { label: currentEncounter.name, image: currentEncounter.characterImage, characterDialogue: !!currentEncounter.characterImage });
            }

            // The dead Mapmaker in the Dead Zone carries his sealed key
            if (currentEncounter.name === 'The Mapmaker' && currentLocation === 'deadzone' && !(game.storyItems || []).includes("Mapmaker's Sealed Key")) {
                addStoryItem("Mapmaker's Sealed Key");
                await addMessage(`You find a sealed key clutched in his other hand. Still warm. He was holding it for you.`, 'system', { label: currentEncounter.name });
            }

            // Grant location map on first engage of any encounter
            {
                const zoneConfig = ZONE_DESTINATIONS[currentLocation];
                if (zoneConfig) {
                    const dest = zoneConfig.destinations.find(d => d.encounterName === currentEncounter.name);
                    if (dest && !(game.storyItems || []).includes(dest.mapItem)) {
                        addStoryItem(dest.mapItem);
                        const cleanName = currentEncounter.name.replace(/^\[COMMON\] /, '');
                        await addMessage(`You've mapped this location. ${cleanName} can now be found directly from the ${LOCATION_NAMES[currentLocation]} destination list.`, 'system');
                        updateDestinationDropdown();
                    }
                }
            }

            // Boss area encounter: check for beacon and trigger fight
            if (currentEncounter.isBossArea) {
                const boss = getBossEncounter();
                if (boss && boss.beacon && (game.storyItems || []).includes(boss.beacon)) {
                    // Has beacon  boss aggros
                    currentEncounter = null;
                    shopItems = [];
                    await addMessage(`The beacon pulses. The signal cuts through  and the ${boss.enemy.name} turns toward you.`, 'system');
                    spawnBossEncounter();
                    return;
                }
                // No beacon  boss ignores you, show dialogue only
                if (currentEncounter.dialogue && currentEncounter.dialogue.length > 0) {
                    showDialogueButtons(currentEncounter);
                }
                return;
            }

            if (currentEncounter.isSalvageYard) {
                await addMessage(`Your Scrap: ${game.scrap || 0}`, 'system');
            }

            // Show dialogue buttons if encounter has dialogue
            if (currentEncounter.dialogue && currentEncounter.dialogue.length > 0) {
                showDialogueButtons(currentEncounter);
            }

            // Add inline leave button in chat (not needed at vendor destinations or decrypter)
            if ((!currentDestination || currentDestination === 'openworld') && currentLocation !== 'decrypter') {
                game.shopLeaveBtn = document.createElement('div');
                game.shopLeaveBtn.className = 'action-btn-container';
                const leaveBtn = document.createElement('button');
                leaveBtn.className = 'action-btn engage';
                leaveBtn.textContent = 'Leave';
                leaveBtn.addEventListener('click', () => {
                    endShopEncounter();
                });
                game.shopLeaveBtn.appendChild(leaveBtn);
                chatMessages.appendChild(game.shopLeaveBtn);
                game.shopLeaveBtn.scrollIntoView({ behavior: 'smooth', block: 'end' });
            }

            showShopPanel();
        }

        // Show dialogue buttons for an encounter with dialogue options
        function showDialogueButtons(encounter) {
            // Remove any existing dialogue buttons
            const existing = document.querySelector('.dialogue-btn-container');
            if (existing) existing.remove();

            const container = document.createElement('div');
            container.className = 'dialogue-btn-container';

            encounter.dialogue.forEach(entry => {
                const btn = document.createElement('button');
                btn.className = 'dialogue-btn';
                btn.textContent = entry.question;
                btn.addEventListener('click', async () => {
                    // Show the player's question
                    await addMessage(entry.question, 'player');
                    // Show the NPC response
                    await addMessage(entry.response, 'system', { label: encounter.name, image: encounter.characterImage, characterDialogue: !!encounter.characterImage });
                    // Re-render dialogue buttons so the player can ask more
                    showDialogueButtons(encounter);
                    // Scroll to the new buttons
                    const newContainer = document.querySelector('.dialogue-btn-container');
                    if (newContainer) newContainer.scrollIntoView({ behavior: 'smooth', block: 'end' });
                });
                container.appendChild(btn);
            });

            chatMessages.appendChild(container);
        }

        // Decline encounter
        function declineEncounter() {
            if (!currentEncounter) return;

            // Clear expire timer and countdown
            if (game.waveExpireTimer) {
                clearTimeout(game.waveExpireTimer);
                game.waveExpireTimer = null;
            }
            clearCountdown();

            addMessage(`Encounter declined. Moving on.`, 'player');
            currentEncounter = null;
            shopItems = [];
            startWaveTimer();
        }

        // Select an asteroid  specific one at named destinations, random (filtered) in open world
        function selectAsteroid() {
            const locationAsteroids = LOCATIONS[currentLocation].mining;
            if (!locationAsteroids || locationAsteroids.length === 0) return null;

            // At a named mining destination: return that specific asteroid
            if (currentDestination && currentDestination !== 'openworld') {
                const mineralName = currentDestination.replace(' Asteroid', '');
                return locationAsteroids.find(a => a.mineral === mineralName) || null;
            }

            // In open world: filter out discovered asteroids
            const zoneConfig = ZONE_DESTINATIONS[currentLocation];
            let available = locationAsteroids;
            if (zoneConfig) {
                available = locationAsteroids.filter(asteroid => {
                    const dest = zoneConfig.destinations.find(d => d.encounterName === `${asteroid.mineral} Asteroid`);
                    if (!dest) return true;
                    return !(game.storyItems || []).includes(dest.mapItem);
                });
            }

            if (available.length === 0) return null;
            return available[Math.floor(Math.random() * available.length)];
        }

        // Spawn mining event
        function spawnMiningEvent() {
            const asteroid = selectAsteroid();
            if (!asteroid) return false;

            currentMiningEvent = {
                mineral: asteroid.mineral,
                category: asteroid.category,
                depth: asteroid.depth,
                stabilityLoss: asteroid.stabilityLoss,
                currentDepth: 0,
                stability: asteroid.stability
            };

            addMessage(`[MINING EVENT] An asteroid with ${asteroid.mineral} deposits at ${asteroid.depth}ft has been detected.`, 'system');
            addMessage(`Asteroid stability: ${asteroid.stability} | Your mining power: ${game.player.mining}`, 'system');

            // Create countdown message
            let secondsLeft = Math.floor(game.WAVE_EXPIRE / 1000);
            const countdownMsg = document.createElement('div');
            countdownMsg.className = 'message system';
            countdownMsg.textContent = `Asteroid in range for [${secondsLeft}] seconds.`;
            chatMessages.appendChild(countdownMsg);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            game.countdownMsg = countdownMsg;

            addMessage(`Do you want to attempt to mine it?`, 'system');

            // Update countdown every second
            game.countdownInterval = setInterval(() => {
                secondsLeft--;
                if (secondsLeft > 0) {
                    countdownMsg.textContent = `Asteroid in range for [${secondsLeft}] seconds.`;
                } else {
                    clearCountdown();
                }
            }, 1000);

            showInlineButtons();

            // Set expiration timer
            if (game.waveExpireTimer) clearTimeout(game.waveExpireTimer);
            game.waveExpireTimer = setTimeout(() => {
                clearCountdown();
                if (currentMiningEvent) {
                    addMessage(`Asteroid has drifted out of range.`, 'system');
                    currentMiningEvent = null;
                    hideInlineButtons();
                    startWaveTimer();
                }
            }, game.WAVE_EXPIRE);

            return true;
        }

        // Engage mining event
        async function engageMining() {
            if (!currentMiningEvent) return;

            // Clear expire timer and countdown
            if (game.waveExpireTimer) {
                clearTimeout(game.waveExpireTimer);
                game.waveExpireTimer = null;
            }
            clearCountdown();

            game.inBattle = true;
            setEquipmentLocked(true);

            if (game.regenInterval) {
                clearInterval(game.regenInterval);
                game.regenInterval = null;
            }

            const mining = currentMiningEvent;

            // Grant asteroid location on first engage in open world
            {
                const zoneConfig = ZONE_DESTINATIONS[currentLocation];
                if (zoneConfig && (!currentDestination || currentDestination === 'openworld')) {
                    const asteroidName = `${mining.mineral} Asteroid`;
                    const dest = zoneConfig.destinations.find(d => d.encounterName === asteroidName);
                    if (dest && !(game.storyItems || []).includes(dest.mapItem)) {
                        addStoryItem(dest.mapItem);
                        await addMessage(`You've logged this asteroid's coordinates. ${asteroidName} can now be found directly from the ${LOCATION_NAMES[currentLocation]} destination list.`, 'system');
                        updateDestinationDropdown();
                    }
                }
            }

            await addMessage(`Mining operation commencing on ${mining.mineral} asteroid...`, 'player');
            await addMessage(`> > >  M I N I N G  S T A R T  < < <`, 'system');

            // Mining loop
            let turn = 0;
            while (mining.stability > 0 && mining.currentDepth < mining.depth) {
                turn++;
                await addMessage(`- - - - - - - - - - - - - - - - - - - - -[${numberToWord(turn)}]- - - - - - - - - - - - - - - - - - - - -`, 'turncounter');

                // Player mines deeper
                mining.currentDepth = Math.min(mining.currentDepth + game.player.mining, mining.depth);
                await addMessage(`Mech mines to ${mining.currentDepth} / ${mining.depth}ft`, 'player');

                // Check if deposit reached
                if (mining.currentDepth >= mining.depth) {
                    await addMessage(`[EXTRACTION COMPLETE] ${mining.mineral} has been successfully extracted.`, 'victory');
                    endMining(true);
                    return;
                }

                // Asteroid loses stability
                mining.stability = Math.max(0, mining.stability - mining.stabilityLoss);

                // Stonebreaker: chance to add mining stat to stability
                const stoneTriggered = hasBreaker("Bolt's Stonebreaker Key") && Math.random() * 100 < getBreaker();
                if (stoneTriggered) {
                    mining.stability += game.player.mining;
                    await addMessage(`[STONEBREAKER TRIGGERED] Bolt reinforces the rock! +${game.player.mining} stability`, 'player');
                }

                await addMessage(`Asteroid stability at ${mining.stability}`, 'system');

                // Check for collapse
                if (mining.stability <= 0) {
                    await addMessage(`[ASTEROID COLLAPSE] The asteroid has destabilised!`, 'enemy');

                    // Collapse damage = current depth, reduced by defence
                    const collapseDamage = mining.currentDepth;
                    const p = game.player;
                    let remainingDefence = p.defence;

                    if (remainingDefence >= collapseDamage) {
                        await addMessage(`Collapse impact: ${collapseDamage} damage. Defence absorbs all damage.`, 'player');
                    } else if (remainingDefence > 0) {
                        const damageTaken = collapseDamage - remainingDefence;
                        await addMessage(`Collapse impact: ${collapseDamage} damage. Defence absorbs ${remainingDefence}, ${damageTaken} damage taken.`, 'player');
                        p.hp = Math.max(0, p.hp - damageTaken);
                        updateStats();
                    } else {
                        p.hp = Math.max(0, p.hp - collapseDamage);
                        await addMessage(`Collapse impact: ${collapseDamage} damage taken.`, 'player');
                        updateStats();
                    }

                    await addMessage(`Mining operation failed. No minerals recovered.`, 'system');

                    if (p.hp <= 0) {
                        game.deaths++;
                        await addMessage(`Your mech has been confirmed destroyed.`, 'system');
                        await addMessage(`Systems resetting.`, 'system');
                        p.hp = Math.floor(p.maxHp / 2);
                    }

                    endMining(false);
                    return;
                }
            }
        }

        // End mining event
        function endMining(success) {
            game.inBattle = false;
            setEquipmentLocked(false);

            if (success) {
                // Add minerals to player's collection (1-3 random yield)
                const yield_ = Math.floor(Math.random() * 3) + 1;
                for (let i = 0; i < yield_; i++) {
                    addMineral(currentMiningEvent.mineral, currentMiningEvent.category);
                }
                addMessage(`Extracted ${yield_}x ${currentMiningEvent.mineral}.`, 'victory');
            }

            currentMiningEvent = null;
            updateStats();
            saveGame();
            startRegen();
            startWaveTimer();
        }

        // Decline mining event
        function declineMining() {
            if (!currentMiningEvent) return;

            // Clear expire timer and countdown
            if (game.waveExpireTimer) {
                clearTimeout(game.waveExpireTimer);
                game.waveExpireTimer = null;
            }
            clearCountdown();

            addMessage(`Mining operation declined. Asteroid ignored.`, 'player');
            currentMiningEvent = null;
            startWaveTimer();
        }

        // Add a mineral to the player's mining collection
        function addMineral(mineralName, category) {
            if (!game.minerals) game.minerals = {};
            if (!game.minerals[category]) game.minerals[category] = [];
            game.minerals[category].push(mineralName);
            updateMiningUI();
            saveGame();
        }

        // Count how many of a specific mineral the player has
        function getMineralCount(mineralName, category) {
            if (!game.minerals || !game.minerals[category]) return 0;
            return game.minerals[category].filter(m => m === mineralName).length;
        }

        // Remove a number of a specific mineral from the player's collection
        function removeMinerals(mineralName, category, count) {
            if (!game.minerals || !game.minerals[category]) return;
            let removed = 0;
            game.minerals[category] = game.minerals[category].filter(m => {
                if (m === mineralName && removed < count) {
                    removed++;
                    return false;
                }
                return true;
            });
        }

        // Check if the player has a specific breaker power (owns the decrypted key)
        function hasBreaker(breakerKeyName) {
            return game.storyItems && game.storyItems.includes(breakerKeyName);
        }

        // Get effective breaker chance (Skybreaker doubles it)
        function getBreaker() {
            const base = game.player.breaker || 0;
            return hasBreaker("Mapmaker's Skybreaker Key") ? Math.min(base * 2, 100) : base;
        }

        // Add a story item to the player's storage
        function addStoryItem(itemName) {
            if (!game.storyItems) game.storyItems = [];
            if (!game.storyItems.includes(itemName)) {
                game.storyItems.push(itemName);
                const item = STORY_ITEMS.find(i => i.name === itemName);
                if (item) {
                    const label = item.category === 'locationmap' ? 'VENDOR FOUND' : 'ITEM FOUND';
                    addMessage(`[${label}] ${item.name}`, 'victory');
                }
                updateStorageUI();
                updateLocationDropdown();
                updateDestinationDropdown();
                saveGame();
            }
        }

        // Update mining page dropdowns to show collected minerals
        function updateMiningUI() {
            if (!game.minerals) return;
            const MINING_LABELS = { tier1: 'TIER 1', tier2: 'TIER 2', tier3: 'TIER 3', tier4: 'TIER 4', tier5: 'TIER 5', tier6: 'TIER 6', tier7: 'TIER 7', tier8: 'TIER 8', tier9: 'TIER 9', tier10: 'TIER 10' };
            const categories = ['tier1', 'tier2', 'tier3', 'tier4', 'tier5', 'tier6', 'tier7', 'tier8', 'tier9', 'tier10'];
            categories.forEach(cat => {
                const select = document.getElementById(`mining-${cat}`);
                if (!select) return;
                const collected = (game.minerals[cat] || []);
                const tag = MINING_LABELS[cat];
                // Count unique minerals collected
                const uniqueCount = new Set(collected.map(m => m.toLowerCase())).size;
                select.options[0].textContent = `[${tag}] ${uniqueCount} minerals`;
                // Count occurrences of each mineral
                const counts = {};
                collected.forEach(m => { counts[m.toLowerCase()] = (counts[m.toLowerCase()] || 0) + 1; });
                // Enable/disable options and show count
                for (let i = 1; i < select.options.length; i++) {
                    const opt = select.options[i];
                    const mineralValue = opt.value;
                    const count = counts[mineralValue] || 0;
                    // Get base mineral name from value (capitalize first letter)
                    const baseName = mineralValue.charAt(0).toUpperCase() + mineralValue.slice(1);
                    if (count > 0) {
                        opt.disabled = false;
                        opt.textContent = count > 1 ? `[${tag}] ${baseName} x${count}` : `[${tag}] ${baseName}`;
                    } else {
                        opt.disabled = true;
                        opt.textContent = `[${tag}] ${baseName}`;
                    }
                }
                // Enable dropdown if player has at least one mineral in this category
                if (collected.length > 0) {
                    select.disabled = false;
                }
            });

            // Handle refined minerals dropdown (dynamically populated)
            const refinedSelect = document.getElementById('mining-refined');
            if (refinedSelect) {
                const collected = game.minerals.refined || [];
                const counts = {};
                collected.forEach(m => { counts[m] = (counts[m] || 0) + 1; });
                // Clear all options except header
                while (refinedSelect.options.length > 1) refinedSelect.remove(1);
                const uniqueMinerals = [...new Set(collected)].sort();
                refinedSelect.options[0].textContent = `[REFINED] ${uniqueMinerals.length} minerals`;
                uniqueMinerals.forEach(m => {
                    const opt = document.createElement('option');
                    opt.value = m;
                    const count = counts[m] || 0;
                    opt.textContent = count > 1 ? `[REFINED] ${m} x${count}` : `[REFINED] ${m}`;
                    refinedSelect.appendChild(opt);
                });
                refinedSelect.disabled = uniqueMinerals.length === 0;
            }
        }

        // Update storage UI dropdowns with collected story items
        function updateStorageUI() {
            const STORAGE_LABELS = { log: 'LOGS', key: 'KEYS', beacon: 'BEACONS', dna: 'DNA', debris: 'DEBRIS', scrap: 'SCRAP', map: 'MAPS', locationmap: 'LOCATIONS' };
            const items = game.storyItems || [];
            const cats = ['log', 'key', 'beacon', 'dna', 'debris', 'map', 'locationmap'];
            cats.forEach(cat => {
                const select = document.getElementById(`storage-${cat}`);
                const desc = document.getElementById(`storage-desc-${cat}`);
                if (!select || !desc) return;
                const tag = STORAGE_LABELS[cat];
                let collected;
                if (cat === 'beacon') {
                    collected = items.map(name => STORY_ITEMS.find(i => i.name === name)).filter(i => i && i.category === 'key' && i.name.startsWith('Beacon:'));
                } else if (cat === 'key') {
                    collected = items.map(name => STORY_ITEMS.find(i => i.name === name)).filter(i => i && i.category === 'key' && !i.name.startsWith('Beacon:'));
                } else {
                    collected = items.map(name => STORY_ITEMS.find(i => i.name === name)).filter(i => i && i.category === cat);
                }
                select.innerHTML = `<option value="">[${tag}] ${collected.length} items</option>`;
                collected.forEach(item => {
                    const opt = document.createElement('option');
                    opt.value = item.name;
                    opt.textContent = `[${tag}] ${item.name}`;
                    select.appendChild(opt);
                });
                select.disabled = collected.length === 0;
                desc.textContent = '';
            });

            // Scrap counter display
            const scrapSelect = document.getElementById('storage-scrap');
            if (scrapSelect) {
                const count = game.scrap || 0;
                scrapSelect.innerHTML = `<option value="">[SCRAP] ${count}</option>`;
                scrapSelect.disabled = true;
            }
        }

        // Storage dropdown change listeners
        ['log', 'key', 'beacon', 'dna', 'debris', 'scrap', 'map', 'locationmap'].forEach(cat => {
            document.getElementById(`storage-${cat}`).addEventListener('change', (e) => {
                const desc = document.getElementById(`storage-desc-${cat}`);
                const item = STORY_ITEMS.find(i => i.name === e.target.value);
                if (item) {
                    desc.innerHTML = `<div class="storage-desc-content"><img src="${item.image}" alt="${item.name}"><span>${item.desc}</span></div>`;
                } else {
                    desc.innerHTML = '';
                }
            });
        });

        // Show action buttons inline in chat (below countdown)
        function showInlineButtons() {
            btnEngage.disabled = false;
            btnRetreat.disabled = false;
            chatMessages.appendChild(btnContainer);
            btnContainer.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }

        // Hide action buttons from chat
        function hideInlineButtons() {
            btnEngage.disabled = true;
            btnRetreat.disabled = true;
            if (btnContainer.parentNode) {
                btnContainer.remove();
            }
        }

        function clearCountdown() {
            if (game.countdownInterval) {
                clearInterval(game.countdownInterval);
                game.countdownInterval = null;
            }
            if (game.countdownMsg) {
                game.countdownMsg.remove();
                game.countdownMsg = null;
            }
            hideInlineButtons();
        }

        // Spawn new wave
        // Select ambush enemy type based on player level and appearance rates
        function selectAmbushType() {
            const loc = LOCATIONS[currentLocation];
            if (!loc.ambush || loc.ambush.length === 0) return null;
            const playerLevel = game.player.level;
            const available = loc.ambush.filter(e => e.minLevel <= playerLevel);
            if (available.length === 0) return null;
            const totalRate = available.reduce((sum, e) => sum + e.appearanceRate, 0);
            let roll = Math.random() * totalRate;
            for (const enemy of available) {
                roll -= enemy.appearanceRate;
                if (roll <= 0) return enemy;
            }
            return available[0];
        }

        // Spawn an ambush event
        function spawnAmbush() {
            const ambushEnemy = selectAmbushType();
            if (!ambushEnemy) return false;

            const min = ambushEnemy.squadMin || 1;
            const max = ambushEnemy.squadMax || 1;
            const enemyCount = Math.floor(Math.random() * (max - min + 1)) + min;

            game.currentWave = {
                enemyType: ambushEnemy,
                count: enemyCount,
                remaining: enemyCount,
                currentTarget: 1,
                currentEnemy: null,
                turn: 0
            };
            game.isAmbush = true;

            addMessage(`[AMBUSH] A squad of ${enemyCount} ${ambushEnemy.name}s has locked onto your location [ATK:${ambushEnemy.attack} DEF:${ambushEnemy.defence} HP:${ambushEnemy.hp}]`, 'enemy');

            // Create countdown message
            let secondsLeft = Math.floor(game.WAVE_EXPIRE / 1000);
            const countdownMsg = document.createElement('div');
            countdownMsg.className = 'message system';
            countdownMsg.textContent = `Contact in [${secondsLeft}] seconds.`;
            chatMessages.appendChild(countdownMsg);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            game.countdownMsg = countdownMsg;

            addMessage(`Hostile signatures closing fast...`, 'player');

            // Update countdown every second
            game.countdownInterval = setInterval(() => {
                secondsLeft--;
                if (secondsLeft > 0) {
                    countdownMsg.textContent = `Contact in [${secondsLeft}] seconds.`;
                } else {
                    clearCountdown();
                }
            }, 1000);

            // Set button text for ambush
            btnRetreat.textContent = 'Evade';
            showInlineButtons();

            // Ambush expires - if player doesn't act, fight starts automatically
            if (game.waveExpireTimer) clearTimeout(game.waveExpireTimer);
            game.waveExpireTimer = setTimeout(() => {
                clearCountdown();
                if (game.currentWave && !game.inBattle) {
                    addMessage(`[CONTACT] No time left  they're on you!`, 'enemy');
                    hideInlineButtons();
                    btnRetreat.textContent = 'Decline';
                    engageBattle();
                }
            }, game.WAVE_EXPIRE);

            return true;
        }

        // Evade an ambush using breaker stat (requires Speedbreaker key)
        function evadeAmbush() {
            if (!game.currentWave || game.inBattle) return;

            // Clear expire timer and countdown
            if (game.waveExpireTimer) {
                clearTimeout(game.waveExpireTimer);
                game.waveExpireTimer = null;
            }
            clearCountdown();

            const p = game.player;
            const hasSpeed = hasBreaker("Wire's Speedbreaker Key");
            const evadeRoll = hasSpeed && Math.random() * 100 < getBreaker();

            if (evadeRoll) {
                addMessage(`[EVADE SUCCESSFUL] Speedbreaker engaged  you slipped their sensors!`, 'player');
                removeBossDialogue();
                game.currentWave = null;
                game.isAmbush = false;
                game.isBossEncounter = false;
                currentBossEncounter = null;
                btnRetreat.textContent = 'Decline';
                startWaveTimer();
            } else {
                addMessage(`[EVADE FAILED] They've cut off your escape  combat is unavoidable!`, 'enemy');
                removeBossDialogue();
                btnRetreat.textContent = 'Decline';
                engageBattle();
            }
        }

        // Evade a boss encounter  always succeeds (100% evasion)
        function evadeBoss() {
            if (!game.currentWave || game.inBattle) return;

            if (game.waveExpireTimer) {
                clearTimeout(game.waveExpireTimer);
                game.waveExpireTimer = null;
            }
            clearCountdown();

            addMessage(`[EVADE SUCCESSFUL] Speedbreaker engaged  you slipped their sensors!`, 'player');
            removeBossDialogue();
            game.currentWave = null;
            game.isAmbush = false;
            game.isBossEncounter = false;
            currentBossEncounter = null;
            btnRetreat.textContent = 'Decline';
            startWaveTimer();
        }

        // Boss encounter toggle
        let bossEncountersEnabled = true;
        document.getElementById('boss-toggle').addEventListener('click', function() {
            bossEncountersEnabled = !bossEncountersEnabled;
            this.classList.toggle('on', bossEncountersEnabled);
            this.title = bossEncountersEnabled ? 'Boss encounters ON' : 'Boss encounters OFF';
        });

        // Get boss encounter data for current zone
        function getBossEncounter() {
            return BOSS_ENCOUNTERS.find(b => b.zone === currentLocation) || null;
        }

        // Spawn a boss encounter
        function spawnBossEncounter() {
            if (!bossEncountersEnabled) return false;
            const boss = getBossEncounter();
            if (!boss) return false;

            // Check if both drops have already been collected  boss already beaten
            const hasKey = (game.storyItems || []).includes(boss.keyDrop);
            const hasDna = (game.storyItems || []).includes(boss.dnaDrop);
            if (hasKey && hasDna) return false;

            // Boss only appears after player activates the zone's beacon
            if (boss.beacon && !(game.storyItems || []).includes(boss.beacon)) return false;

            // Use enemy stats from boss encounter data
            const bossEnemy = boss.enemy;
            if (!bossEnemy) return false;

            currentBossEncounter = boss;

            // Set up the wave with the boss enemy (always solo)
            game.currentWave = {
                enemyType: bossEnemy,
                count: 1,
                remaining: 1,
                currentTarget: 1,
                currentEnemy: null,
                turn: 0
            };
            game.isBossEncounter = true;

            addMessage(`[BOSS ENCOUNTER] ${boss.introText}`, 'enemy');

            // Create countdown message
            let secondsLeft = Math.floor(game.WAVE_EXPIRE / 1000);
            const countdownMsg = document.createElement('div');
            countdownMsg.className = 'message system';
            countdownMsg.textContent = `The ${bossEnemy.name} is closing in. [${secondsLeft}] seconds.`;
            chatMessages.appendChild(countdownMsg);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            game.countdownMsg = countdownMsg;

            addMessage(`Something massive is approaching...`, 'player');

            // Update countdown every second
            game.countdownInterval = setInterval(() => {
                secondsLeft--;
                if (secondsLeft > 0) {
                    countdownMsg.textContent = `The ${bossEnemy.name} is closing in. [${secondsLeft}] seconds.`;
                } else {
                    clearCountdown();
                }
            }, 1000);

            // Set button text for boss encounter
            btnRetreat.textContent = 'Evade';
            showInlineButtons();

            // Boss encounter expires  auto-engage if player doesn't act
            if (game.waveExpireTimer) clearTimeout(game.waveExpireTimer);
            game.waveExpireTimer = setTimeout(() => {
                clearCountdown();
                if (game.currentWave && !game.inBattle && game.isBossEncounter) {
                    addMessage(`[CONTACT] The ${bossEnemy.name} is on you  no time to talk!`, 'enemy');
                    hideInlineButtons();
                    removeBossDialogue();
                    btnRetreat.textContent = 'Decline';
                    engageBattle();
                }
            }, game.WAVE_EXPIRE);

            return true;
        }

        // Show boss dialogue  dialogue first, then [FIGHT] after interaction
        function showBossDialogue() {
            if (!currentBossEncounter) return;

            // Clear expire timer  boss stays while player is talking
            if (game.waveExpireTimer) {
                clearTimeout(game.waveExpireTimer);
                game.waveExpireTimer = null;
            }
            clearCountdown();
            hideInlineButtons();

            // Remove any existing boss dialogue
            removeBossDialogue();

            const container = document.createElement('div');
            container.className = 'dialogue-btn-container boss-dialogue';

            // Add dialogue questions  clicking one shows the response, then reveals [FIGHT]
            currentBossEncounter.dialogue.forEach(entry => {
                const btn = document.createElement('button');
                btn.className = 'dialogue-btn';
                btn.textContent = entry.question;
                btn.addEventListener('click', async () => {
                    removeBossDialogue();
                    await addMessage(entry.question, 'player');
                    await addMessage(entry.response, 'system', { label: currentBossEncounter.enemy.name, image: currentBossEncounter.characterImage, characterDialogue: !!currentBossEncounter.characterImage });
                    showBossFightButton();
                });
                container.appendChild(btn);
            });

            chatMessages.appendChild(container);
            container.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }

        // Show only the [FIGHT] button after dialogue interaction
        function showBossFightButton() {
            removeBossDialogue();

            const container = document.createElement('div');
            container.className = 'dialogue-btn-container boss-dialogue';

            const fightBtn = document.createElement('button');
            fightBtn.className = 'dialogue-btn';
            fightBtn.textContent = '[FIGHT]';
            fightBtn.addEventListener('click', () => {
                removeBossDialogue();
                const et = game.currentWave.enemyType;
                addMessage(`[ENGAGING BOSS] ${et.name} [ATK:${et.attack} DEF:${et.defence} HP:${et.hp}]`, 'enemy');
                engageBattle();
            });
            container.appendChild(fightBtn);

            chatMessages.appendChild(container);
            container.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }

        // Remove boss dialogue buttons
        function removeBossDialogue() {
            const existing = document.querySelector('.boss-dialogue');
            if (existing) existing.remove();
        }

        function spawnWave() {
            if (game.inBattle || game.currentWave || currentEncounter || currentMiningEvent) return;

            // At a named destination: spawn the appropriate event
            if (currentDestination && currentDestination !== 'openworld') {
                const loc = LOCATIONS[currentLocation];
                if (currentDestination.endsWith(' Asteroid') || (!loc.enemies && !loc.encounters && loc.mining)) {
                    // Mining destination (asteroid in any zone, or mining-only zone)
                    if (game.player.mining > 0) {
                        spawnMiningEvent();
                    } else {
                        addMessage(`[NO DRILL EQUIPPED] Mining drill required to operate in this zone.`, 'system');
                    }
                } else {
                    spawnEncounter();
                }
                return;
            }

            const loc = LOCATIONS[currentLocation];

            // Mining-only locations: only spawn mining events
            if (!loc.enemies && !loc.encounters && loc.mining) {
                if (game.player.mining > 0) {
                    if (!spawnMiningEvent()) {
                        addMessage(`[NO NEW ASTEROIDS] All asteroid types in this field have been mapped. Select a known asteroid from the destination list.`, 'system');
                    }
                } else {
                    addMessage(`[NO DRILL EQUIPPED] Mining drill required to operate in this zone.`, 'system');
                }
                return;
            }

            // Boss-only locations: always attempt boss encounter
            if (!loc.enemies && !loc.encounters && !loc.mining) {
                if (!spawnBossEncounter()) {
                    addMessage(`[ZONE CLEAR] No threats detected. The war is over.`, 'system');
                }
                return;
            }

            // Encounter-only locations: always spawn encounters
            if (!loc.enemies && loc.encounters) {
                spawnEncounter();
                return;
            }

            // Check for encounter chance
            if (Math.random() * 100 < game.ENCOUNTER_CHANCE) {
                if (spawnEncounter()) return;
            }

            // Check for ambush chance
            if (loc.ambush && Math.random() * 100 < AMBUSH_CHANCE) {
                if (spawnAmbush()) return;
            }

            // Check for mining event chance (only if player has mining stat > 0)
            if (game.player.mining > 0 && Math.random() * 100 < MINING_CHANCE) {
                if (spawnMiningEvent()) return;
            }

            game.currentWave = generateWave();
            const et = game.currentWave.enemyType;
            addMessage(`[TARGET ACQUIRED]> ${game.currentWave.count} ${et.name}s are within engagement range [ATK:${et.attack} DEF:${et.defence} HP:${et.hp}]`, 'enemy');

            // Create countdown message
            let secondsLeft = Math.floor(game.WAVE_EXPIRE / 1000);
            const countdownMsg = document.createElement('div');
            countdownMsg.className = 'message system';
            countdownMsg.textContent = `Enemy location locked [${secondsLeft}] seconds until EMP signal jam.`;
            chatMessages.appendChild(countdownMsg);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            game.countdownMsg = countdownMsg;

            // Update countdown every second
            game.countdownInterval = setInterval(() => {
                secondsLeft--;
                if (secondsLeft > 0) {
                    countdownMsg.textContent = `Enemy signal locked. [${secondsLeft}] seconds until signal loss.`;
                } else {
                    clearCountdown();
                }
            }, 1000);

            showInlineButtons();

            // Set expiration timer
            if (game.waveExpireTimer) clearTimeout(game.waveExpireTimer);
            game.waveExpireTimer = setTimeout(() => {
                clearCountdown();
                if (game.currentWave && !game.inBattle) {
                    addMessage(`Signal lost. Scanning...`, 'system', { image: 'images/Comp 1.gif' });
                    game.currentWave = null;
                    hideInlineButtons();
                    startWaveTimer();
                }
            }, game.WAVE_EXPIRE);
        }

        // Start wave timer
        function startWaveTimer() {
            game.nextWaveTime = Date.now() + game.WAVE_INTERVAL;

            if (game.waveTimer) clearInterval(game.waveTimer);

            game.waveTimer = setInterval(() => {
                const remaining = Math.max(0, game.nextWaveTime - Date.now());
                const minutes = Math.floor(remaining / 60000);
                const seconds = Math.floor((remaining % 60000) / 1000);
                timerDisplay.textContent = `Next wave in: ${minutes}:${seconds.toString().padStart(2, '0')}`;

                if (remaining <= 0) {
                    spawnWave();
                    startWaveTimer();
                }
            }, 1000);
        }

        // Player attack helper - calculates damage vs enemy defence
        function calculateDamage(attackStat, defenceStat) {
            const damage = Math.max(1, attackStat - defenceStat);
            return damage;
        }

        // Battle round - player attacks, then all enemies attack in sequence
        async function battleRound() {
            const p = game.player;
            const wave = game.currentWave;
            const et = wave.enemyType;

            if (!wave || wave.remaining <= 0 || p.hp <= 0) {
                endBattle();
                return;
            }

            // Spawn new enemy if needed
            if (wave.currentEnemy === null) {
                wave.currentEnemy = et.hp;
            }

            wave.turn++;
            await addMessage(`- - - - - - - - - - - - - - - - - - - - -[${numberToWord(wave.turn)}]- - - - - - - - - - - - - - - - - - - - -`, 'turncounter');

            // Determine breaker procs this turn (gated behind owning decrypted keys)
            let speedTriggered = hasBreaker("Wire's Speedbreaker Key") && Math.random() * 100 < getBreaker();
            let breakerTriggered = hasBreaker("Your Combobreaker Key") && Math.random() * 100 < getBreaker();
            let strikeTriggered = hasBreaker("Fang's Strikebreaker Key") && Math.random() * 100 < getBreaker();
            let crushTriggered = hasBreaker("Anvil's Crushbreaker Key") && Math.random() * 100 < getBreaker();
            let warTriggered = hasBreaker("Rex's Warbreaker Key") && (speedTriggered || breakerTriggered) && Math.random() * 100 < getBreaker();
            let attackCount = speedTriggered ? (warTriggered ? 4 : 2) : 1;

            if (speedTriggered) {
                await addMessage(`[SPEEDBREAKER TRIGGERED]`, 'player');
            }
            if (strikeTriggered) {
                await addMessage(`[STRIKEBREAKER TRIGGERED] Enemy defence ignored!`, 'player');
            }
            if (breakerTriggered) {
                await addMessage(`[COMBOBREAKER TRIGGERED]`, 'player');
            }
            if (crushTriggered) {
                await addMessage(`[CRUSHBREAKER TRIGGERED] Damage hits all enemies!`, 'player');
            }
            if (warTriggered) {
                await addMessage(`[WARBREAKER TRIGGERED] Escalating to 4X!`, 'player');
            }

            // Calculate damage (strikebreaker ignores enemy defence, combobreaker doubles/quadruples)
            let playerDamage = calculateDamage(p.attack, strikeTriggered ? 0 : et.defence);
            if (breakerTriggered) {
                playerDamage *= warTriggered ? 4 : 2;
            }

            // Perform attacks
            for (let atk = 1; atk <= attackCount; atk++) {
                // If current enemy is dead, target next one
                if (wave.currentEnemy === null) {
                    if (wave.remaining <= 0) {
                        endBattle(true);
                        return;
                    }
                    wave.currentEnemy = et.hp;
                }

                wave.currentEnemy -= playerDamage;
                await addMessage(`Mech attacks ${et.name} #${wave.currentTarget} for ${playerDamage} damage.`, 'player');

                // Crushbreaker AoE: damage all other remaining enemies (first attack only)
                if (crushTriggered && atk === 1 && wave.remaining > 1) {
                    let backgroundCount = wave.remaining - 1;
                    if (playerDamage >= et.hp) {
                        for (let k = 0; k < backgroundCount; k++) {
                            wave.remaining--;
                            const xpBonus = getXpBonus();
                            const killXp = et.xp + xpBonus;
                            wave.xpEarned = (wave.xpEarned || 0) + killXp;
                            const bonusText = xpBonus > 0 ? ` (+${xpBonus} PROC)` : '';
                            await addMessage(`[KILL CONFIRMED] ${et.name} destroyed by Crushbreaker (+${killXp} Silicon${bonusText})`, 'enemy');
                        }
                        wave.count = wave.currentTarget;
                    } else {
                        await addMessage(`Crushbreaker hits ${backgroundCount} other ${backgroundCount === 1 ? 'enemy' : 'enemies'} for ${playerDamage} damage each.`, 'player');
                    }
                }

                // Check if current enemy
                if (wave.currentEnemy <= 0) {
                    wave.remaining--;
                    const xpBonus = getXpBonus();
                    const killXp = et.xp + xpBonus;
                    wave.xpEarned = (wave.xpEarned || 0) + killXp;
                    const bonusText = xpBonus > 0 ? ` (+${xpBonus} PROC)` : '';
                    await addMessage(`[KILL CONFIRMED] ${et.name} #${wave.currentTarget} destroyed (+${killXp} Silicon${bonusText})`, 'enemy');
                    wave.currentTarget++;
                    wave.currentEnemy = null;

                    if (wave.remaining <= 0) {
                        endBattle(true);
                        return;
                    }
                } else {
                    await addMessage(`${et.name} #${wave.currentTarget} reduced to ${wave.currentEnemy} of ${et.hp} HP`, 'enemy');
                }
            }

            // Shieldbreaker: chance to double defence at start of round
            let remainingDefence = p.defence;
            const shieldTriggered = hasBreaker("Sarge's Shieldbreaker Key") && Math.random() * 100 < getBreaker();
            if (shieldTriggered) {
                remainingDefence *= 2;
                await addMessage(`[SHIELDBREAKER TRIGGERED] Defence doubled to ${remainingDefence}!`, 'player');
            }

            // All remaining enemies attack in sequence

            for (let i = wave.currentTarget; i <= wave.count; i++) {
                await addMessage(`${et.name} #${i} attacks Mech for ${et.attack} damage.`, 'enemy');

                // Visionbreaker: chance to completely avoid this attack
                const visionTriggered = hasBreaker("Ghost's Visionbreaker Key") && Math.random() * 100 < getBreaker();
                if (visionTriggered) {
                    await addMessage(`[VISIONBREAKER TRIGGERED] You disappeared  attack missed!`, 'player');
                    continue;
                }

                // Soulbreaker: chance to parry attack and reflect damage back
                const soulTriggered = hasBreaker("Null's Soulbreaker Key") && Math.random() * 100 < getBreaker();
                if (soulTriggered) {
                    await addMessage(`[SOULBREAKER TRIGGERED] Attack parried  ${et.attack} damage reflected!`, 'player');
                    if (i === wave.currentTarget && wave.currentEnemy !== null) {
                        wave.currentEnemy -= et.attack;
                        if (wave.currentEnemy <= 0) {
                            wave.remaining--;
                            const xpBonus = getXpBonus();
                            const killXp = et.xp + xpBonus;
                            wave.xpEarned = (wave.xpEarned || 0) + killXp;
                            const bonusText = xpBonus > 0 ? ` (+${xpBonus} PROC)` : '';
                            await addMessage(`[KILL CONFIRMED] ${et.name} #${wave.currentTarget} destroyed by parry (+${killXp} Silicon${bonusText})`, 'enemy');
                            wave.currentTarget++;
                            wave.currentEnemy = null;
                            if (wave.remaining <= 0) {
                                endBattle(true);
                                return;
                            }
                        }
                    }
                    continue;
                }

                if (remainingDefence >= et.attack) {
                    // Fully blocked
                    remainingDefence -= et.attack;
                    await addMessage(` [Damage blocked] (${remainingDefence} defence remaining)`, 'player');
                } else if (remainingDefence > 0) {
                    // Partially blocked
                    const damageTaken = et.attack - remainingDefence;
                    await addMessage(`Remaining defence absorbs ${remainingDefence} damage, but ${damageTaken} damage is still taken.`, 'player');
                    remainingDefence = 0;
                    p.hp = Math.max(0, p.hp - damageTaken);
                    updateStats();
                } else {
                    // No defence left
                    p.hp = Math.max(0, p.hp - et.attack);
                    await addMessage(`Mech takes ${et.attack} damage.`, 'player');
                    updateStats();
                }

                // Check if player defeated
                if (p.hp <= 0) {
                    endBattle(false);
                    return;
                }
            }

            // End-of-round regen
            if (p.regen > 0 && p.hp < p.maxHp) {
                const healed = Math.min(p.regen, p.maxHp - p.hp);
                p.hp += healed;
                await addMessage(`Mech regenerates ${healed} HP. (${p.hp}/${p.maxHp})`, 'player');
                updateStats();
            }

            // Painbreaker: chance to regain HP equal to regen stat
            if (hasBreaker("Frost's Painbreaker Key") && p.regen > 0 && p.hp < p.maxHp && Math.random() * 100 < getBreaker()) {
                const painHealed = Math.min(p.regen, p.maxHp - p.hp);
                p.hp += painHealed;
                await addMessage(`[PAINBREAKER TRIGGERED] Mech restores ${painHealed} HP! (${p.hp}/${p.maxHp})`, 'player');
                updateStats();
            }
        }

        // End battle
        function endBattle(victory = false) {
            game.inBattle = false;
            setEquipmentLocked(false); // Unlock equipment

            if (game.battleInterval) {
                clearInterval(game.battleInterval);
                game.battleInterval = null;
            }

            const wave = game.currentWave;
            const enemiesKilled = wave ? wave.count - wave.remaining : 0;
            const xpEarned = wave ? (wave.xpEarned || 0) : 0;
            const enemyType = wave ? wave.enemyType.name : null;

            if (victory) {
                addMessage(`[ All hostiles confirmed destroyed ]`, 'system');

                // Powerbreaker: chance to double silicon gain
                const powerTriggered = hasBreaker("Ace's Powerbreaker Key") && Math.random() * 100 < getBreaker();
                let finalXp = xpEarned;
                if (powerTriggered) {
                    finalXp *= 2;
                    addMessage(`[POWERBREAKER TRIGGERED] Double Silicon earned!`, 'player');
                }

                game.player.xp += finalXp;
                addMessage(`${finalXp} Silicon.`, 'victory', { label: 'Item found:' });

                // Drop random item
                if (enemyType) {
                    const droppedItem = getRandomItemDrop(enemyType);
                    if (droppedItem) {
                        addItemToInventory(droppedItem);
                        addMessage(`${droppedItem.name} [${ITEM_TYPES[droppedItem.type]}]`, 'victory', { label: 'Item found:' });
                    }
                }

                // Scrap drop (per-enemy scrapChance and scrapMin/scrapMax)
                const et = wave ? wave.enemyType : null;
                if (et && et.scrapChance && Math.random() * 100 < et.scrapChance) {
                    let scrapAmount = et.scrapMin + Math.floor(Math.random() * (et.scrapMax - et.scrapMin + 1));

                    // Steelbreaker: chance to double scrap
                    const steelTriggered = hasBreaker("Chunk's Steelbreaker Key") && Math.random() * 100 < getBreaker();
                    if (steelTriggered) {
                        scrapAmount *= 2;
                        addMessage(`[STEELBREAKER TRIGGERED] Double scrap salvaged!`, 'player');
                    }

                    game.scrap += scrapAmount;
                    addMessage(`Salvaged ${scrapAmount} scrap from the wreckage.`, 'victory', { label: 'Item found:' });
                    updateStorageUI();
                }

                // Boss encounter drops: key + DNA tag
                if (game.isBossEncounter && currentBossEncounter) {
                    addMessage(`[BOSS DEFEATED] The ${enemyType} falls.`, 'victory');
                    addStoryItem(currentBossEncounter.keyDrop);
                    addStoryItem(currentBossEncounter.dnaDrop);
                }

                checkLevelUp();
            } else {
                game.deaths++;
                addMessage(`Your mech has been confirmed destroyed.`, 'system');
                addMessage(`Systems resetting.`, 'system');
                // Respawn with half HP
                game.player.hp = Math.floor(game.player.maxHp / 2);
            }

            game.currentWave = null;
            game.isAmbush = false;
            game.isBossEncounter = false;
            currentBossEncounter = null;
            btnRetreat.textContent = 'Decline';
            updateStats();
            startRegen();
            startWaveTimer();
        }

        // Start HP regeneration (1 regen = 1 HP per second)
        function startRegen() {
            if (game.regenInterval) clearInterval(game.regenInterval);
            if (game.player.regen <= 0) return;

            game.regenInterval = setInterval(() => {
                if (game.inBattle) return;

                if (game.player.hp < game.player.maxHp) {
                    game.player.hp = Math.min(game.player.maxHp, game.player.hp + game.player.regen);
                    updateStats();
                } else {
                    clearInterval(game.regenInterval);
                    game.regenInterval = null;
                }
            }, 1000);
        }

        // Fuel regeneration (1 fuel per 3 seconds, always running)
        function startFuelRegen() {
            if (game.fuelRegenInterval) clearInterval(game.fuelRegenInterval);
            game.fuelRegenInterval = setInterval(() => {
                if (game.player.fuel < game.player.maxFuel) {
                    game.player.fuel = Math.min(game.player.maxFuel, game.player.fuel + 1);
                    updateStats();
                }
            }, 3000);
        }

        // Utility delay
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Engage battle
        async function engageBattle() {
            if (!game.currentWave || game.inBattle) return;

            // Clear expire timer and countdown
            if (game.waveExpireTimer) {
                clearTimeout(game.waveExpireTimer);
                game.waveExpireTimer = null;
            }
            clearCountdown();

            game.inBattle = true;
            setEquipmentLocked(true); // Lock equipment during battle

            if (game.regenInterval) {
                clearInterval(game.regenInterval);
                game.regenInterval = null;
            }

            const et = game.currentWave.enemyType;
            await addMessage(`Engagement confirmed for ${game.currentWave.count} ${et.name}s!`, 'player');
            await addMessage(`> > >  C O M B A T  S T A R T  < < <`, 'system');

            // Battle loop
            async function runBattle() {
                while (game.inBattle && game.currentWave && game.currentWave.remaining > 0 && game.player.hp > 0) {
                    await battleRound();
                }
            }

            runBattle().catch(() => {
                if (game.inBattle) endBattle(false);
            });
        }

        // Decline battle
        function declineBattle() {
            if (!game.currentWave || game.inBattle) return;

            // Clear expire timer and countdown
            if (game.waveExpireTimer) {
                clearTimeout(game.waveExpireTimer);
                game.waveExpireTimer = null;
            }
            clearCountdown();

            addMessage(`Engagement denied. Live to fight another day.`, 'player');
            game.currentWave = null;
            startWaveTimer();
        }

        // Event listeners
        btnEngage.addEventListener('click', () => {
            if (currentMiningEvent) {
                engageMining();
            } else if (currentEncounter) {
                engageEncounter();
            } else if (game.isBossEncounter) {
                showBossDialogue();
            } else {
                engageBattle();
            }
        });
        btnRetreat.addEventListener('click', () => {
            if (currentMiningEvent) {
                declineMining();
            } else if (currentEncounter) {
                declineEncounter();
            } else if (game.isBossEncounter && !game.inBattle) {
                evadeBoss(); // Boss evasion always succeeds
            } else if (game.isAmbush) {
                evadeAmbush();
            } else {
                declineBattle();
            }
        });

        // Options modal event listeners
        document.getElementById('btn-options').addEventListener('click', () => {
            refreshSlotDisplays();
            document.getElementById('save-modal').classList.add('visible');
        });
        document.getElementById('modal-close').addEventListener('click', () => {
            document.getElementById('save-modal').classList.remove('visible');
        });
        document.getElementById('save-modal').addEventListener('click', (e) => {
            if (e.target === e.currentTarget) {
                document.getElementById('save-modal').classList.remove('visible');
            }
        });

        // Shop button event listeners
        document.getElementById('shop-buy-1').addEventListener('click', () => purchaseItem(0));
        document.getElementById('shop-buy-2').addEventListener('click', () => purchaseItem(1));
        document.getElementById('shop-buy-3').addEventListener('click', () => purchaseItem(2));

        // Forge mineral dropdown listener
        document.getElementById('forge-mineral-select').addEventListener('change', onForgeMineralChange);

        // Decrypter key dropdown listener
        document.getElementById('decrypter-key-select').addEventListener('change', onDecrypterKeyChange);

        // Salvage yard listeners
        document.getElementById('salvage-item-select').addEventListener('change', onSalvageItemChange);
        document.getElementById('salvage-sell-btn').addEventListener('click', sellSalvageItem);
        document.getElementById('salvage-sell-all-btn').addEventListener('click', sellAllSalvageItems);

        // Initialize game
        function init() {
            // Check for landing page action
            const landingSlot = localStorage.getItem('combobreaker_landing_slot');
            const landingAction = localStorage.getItem('combobreaker_landing_action');
            localStorage.removeItem('combobreaker_landing_slot');
            localStorage.removeItem('combobreaker_landing_action');

            // Set up equipment dropdown event listeners
            const slots = ['body', 'legs', 'arms', 'weapon', 'chip', 'processor', 'pilot', 'drill', 'implant', 'mindsync'];
            slots.forEach(slot => {
                document.getElementById(`equip-${slot}`).addEventListener('change', (e) => {
                    onEquipmentChange(slot, e.target.value);
                });
            });

            // If we came from the landing page, handle the action
            if (landingSlot && landingAction) {
                const slotNum = parseInt(landingSlot);
                if (landingAction === 'new') {
                    // Fresh start on empty slot
                    updateLocationDropdown();
                    updateDestinationDropdown();
                    updateEquipmentUI();
                    updateMiningUI();
                    updateStorageUI();
                    updateStats();
                    newGame(slotNum);
                    return;
                } else if (landingAction === 'load') {
                    loadFromSlot(slotNum);
                    recalculateStats();
                    game.player.hp = game.player.maxHp;
                    updateLocationDropdown();
                    updateDestinationDropdown();
                    updateEquipmentUI();
                    updateMiningUI();
                    updateStorageUI();

                    addMessage(`============================================`, 'system');
                    addMessage(`=== C O M B O B R E A K E R  O N L I N E ===`, 'system');
                    addMessage(`============================================`, 'system');
                    addMessage(`[SAVE DATA LOADED] Welcome back, Pilot 72632`, 'system');
                    addMessage(`Level ${game.player.level} | Silicon: ${game.player.xp}/${game.player.xpToLevel} | ${game.inventory.length} items in inventory`, 'system');
                    addMessage(``, 'system');
                    addMessage(`[] Engagement Protocols Approved [Autopilot Deactivated] `, 'system');
                    addMessage(`[K E Y //::X2Y***_***_***_***_***_LZ7`, 'system');
                    addMessage(`BreakerPilot Command Key Accepted.`, 'system');
                    addMessage(`Engagement commands now available. [Engage] or [Decline]`, 'system');
                    updateStats();
                    startFuelRegen();
                    setTimeout(() => {
                        spawnWave();
                        startWaveTimer();
                    }, 2000);
                    return;
                }
            }

            // No landing action  redirect to landing page
            window.location.href = 'landing.html';
        }

        init();
    </script>
</body>
</html>































